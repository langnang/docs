
# Vue

- https://cn.vuejs.org/

#### vue是什么？有什么作用？有什么优缺点？

轻量级框架: 只关注视图层，是一个构建数据的视图集合，大小只有几十kb；  

简单易学: 国人开发，中文文档，不存在语言障碍 ，易于理解和学习；  

双向数据绑定: 保留了angular的特点，在数据操作方面更为简单；  

组件化: 保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；  

视图，数据，结构分离: 使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；  

虚拟DOM: dom操作是非常耗费性能的， 不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；  

运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。  

#### 如何让CSS只在当前组件中起作用？

在组件中的style前面加上scoped  

#### 如何获取dom?

ref="domName" 用法: this.$refs.domName  

#### axios及安装?  

请求后台资源的模块。npm install axios --save装好，  
js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中。  

#### v-modal的使用。

v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作:
v-bind绑定一个value属性；  
v-on指令给当前元素绑定input事件。  



#### v-on可以监听多个方法吗？  

可以的

```html
<input type="text" v-on="{ input:onInput,focus:onFocus,blur:onBlur, }">
```

#### 引进组件的步骤

在template中引入组件；

在script的第一行用import引入路径；  
用component中写上组件名称。  

#### delete和Vue.delete删除数组的区别

delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。Vue.delete 直接删除了数组 改变了数组的键值。  

#### SPA首屏加载慢如何解决

安装动态懒加载所需插件；使用CDN资源。  

#### vue slot

简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，就是slot分发负责的活。  

#### 你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？

根据vue-cli脚手架规范，一个js文件，一个CSS文件。  





#### axios的特点有哪些

从浏览器中创建XMLHttpRequests；  
node.js创建http请求；  
支持Promise API；  
拦截请求和响应；  
转换请求数据和响应数据；  
取消请求；  
自动换成json。  
axios中的发送字段的参数是data跟params两个，两者的区别在于params是跟请求地址一起发送的，data的作为一个请求体进行发送  
params一般适用于get请求，data一般适用于post put 请求。  

1. 4.

#### vue初始化页面闪动问题

使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。  
首先: 在css里加上[v-cloak] {  
display: none;  
}。  
如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: 'block'}"  

#### vue更新数组时触发视图更新的方法

push()；pop()；shift()；unshift()；splice()； sort()；reverse()  

#### vue常用的UI组件库

Mint UI，element，VUX  

#### vue修改打包后静态资源路径的修改

cli2版本: 将 config/index.js 里的 assetsPublicPath 的值改为 './' 。  
build: {  
...  
assetsPublicPath: './',  
...  
}  
cli3版本: 在根目录下新建vue.config.js 文件，然后加上以下内容: （如果已经有此文件就直接修改）  
module.exports = {  
publicPath: '', // 相对于 HTML 页面（目录相同） }  

#### 谈一谈对 `MVVM` 的理解？



- *MVVM* 是 *Model-View-ViewModel* 的缩写。*MVVM* 是一种设计思想。
- *Model* 层代表数据模型，也可以在 *Model* 中定义数据修改和操作的业务逻辑;
- *View* 代表 *UI* 组件，它负责将数据模型转化成 *UI* 展现出来，*View* 是一个同步 *View* 和 *Model* 的对象
- 在 *MVVM* 架构下，*View* 和 *Model* 之间并没有直接的联系，而是通过 *ViewModel* 进行交互， *Model* 和 *ViewModel* 之间的交互是双向的， 因此 *View* 数据的变化会同步到 *Model* 中，而 *Model* 数据的变化也会立即反应到 *View* 上。
- 对 *ViewModel* 通过双向数据绑定把 *View* 层和 *Model* 层连接了起来，而 *View* 和 *Model* 之间的 同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 *DOM*，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 *MVVM* 来统一管理。

#### 说一下 `Vue` 的优点



*Vue* 是一个构建数据驱动的 *Web* 界面的渐进式框架。

*Vue* 的目标是通过尽可能简单的 *API* 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。

关于 *Vue* 的优点，主要有**响应式编程、组件化开发、虚拟 `DOM`**

**响应式编程**

这里的响应式不是 *@media* 媒体查询中的响应式布局，而是指 *Vue* 会自动对页面中某些数据的变化做出响应。这也就是 *Vue* 最大的优点，通过 *MVVM* 思想实现数据的双向绑定，让开发者不用再操作 *DOM* 对象，有更多的时间去思考业务逻辑。

**组件化开发**

*Vue* 通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（*component*）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。

组件化开发的优点: 提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。

**虚拟 `DOM`**

在传统开发中，用 *JQuery* 或者原生的 *JavaScript DOM* 操作函数对 *DOM* 进行频繁操作的时候，浏览器要不停的渲染新的 *DOM* 树，导致在性能上面的开销特别的高。

而 *Virtual DOM* 则是虚拟 *DOM* 的英文，简单来说，他就是一种可以预先通过 *JavaScript* 进行各种计算，把最终的 *DOM* 操作计算出来并优化，由于这个 *DOM* 操作属于预处理操作，并没有真实的操作 *DOM*，所以叫做虚拟 *DOM*。最后在计算完毕才真正将 *DOM* 操作提交，将 *DOM* 操作变化反映到 *DOM* 树上。

- *

#### `Vue` 实现双向数据绑定原理是什么？



*Vue2.x* 采用数据劫持结合发布订阅模式（*PubSub* 模式）的方式，通过 *Object.defineProperty* 来劫持各个属性的 *setter、getter*，在数据变动时发布消息给订阅者，触发相应的监听回调。

当把一个普通 *Javascript* 对象传给 *Vue* 实例来作为它的 *data* 选项时，*Vue* 将遍历它的属性，用 *Object.defineProperty* 将它们转为 *getter/setter*。用户看不到 *getter/setter*，但是在内部它们让 *Vue* 追踪依赖，在属性被访问和修改时通知变化。

*Vue* 的数据双向绑定整合了 *Observer*，*Compile* 和 *Watcher* 三者，通过 *Observer* 来监听自己的 *model* 的数据变化，通过 *Compile* 来解析编译模板指令，最终利用 *Watcher* 搭起 *Observer* 和 *Compile* 之间的通信桥梁，达到数据变化->视图更新，视图交互变化（例如 input 操作）->数据 *model* 变更的双向绑定效果。

*Vue3.x* 放弃了 *Object.defineProperty* ，使用 *ES6* 原生的 *Proxy*，来解决以前使用 *Object.defineProperty* 所存在的一些问题。

#### 说一下对 `Vue2.x` 响应式原理的理解



*Vue* 在初始化数据时，会使用 *Object.defineProperty* 重新定义 *data* 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 *watcher*)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。

（可以参阅前面第 *4* 题答案）

#### 说一下在 `Vue2.x` 中如何检测数组的变化？



*Vue2.x* 中实现检测数组变化的方法，是**将数组的常用方法进行了重写**。*Vue* 将 *data* 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 *api* 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

流程:

1. 初始化传入 data 数据执行 initData
2. 将数据进行观测 new Observer
3. 将数组原型方法指向重写的原型
4. 深度观察数组中的引用类型

有两种情况无法检测到数组的变化。

- 当利用索引直接设置一个数组项时，例如 *vm.items[indexOfItem] = newValue*
- 当修改数组的长度时，例如 *vm.items.length = newLength*

不过这两种场景都有对应的解决方案。

**利用索引设置数组项的替代方案**

```js
//使用该方法进行更新视图
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
```

**修改数组的长度的替代方案**

```js
//使用该方法进行更新视图
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```



#### `Vue3.x` 响应式数据

- *Vue3.x* 响应式数据原理是什么？
- *Proxy* 只会代理对象的第一层，那么 *Vue3* 又是怎样处理这个问题的呢？
- 监测数组的时候可能触发多次 *get/set*，那么如何防止触发多次呢？



#### `Vue3.x` 响应式数据原理是什么？

在 *Vue 2* 中，响应式原理就是使用的 *Object.defineProperty* 来实现的。但是在 *Vue 3.0* 中采用了 *Proxy*，抛弃了 *Object.defineProperty* 方法。

究其原因，主要是以下几点:

- *Object.defineProperty* 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应
- *Object.defineProperty* 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。*Proxy* 可以劫持整个对象，并返回一个新的对象。
- *Proxy* 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。
- *Proxy* 有多达 *13* 种拦截方法
- *Proxy*作为新标准将受到浏览器厂商重点持续的性能优化

#### `Proxy` 只会代理对象的第一层，那么 `Vue3` 又是怎样处理这个问题的呢？

判断当前 *Reflect.get* 的返回值是否为 *Object*，如果是则再通过 *reactive* 方法做代理， 这样就实现了深度观测。

#### 监测数组的时候可能触发多次 `get/set`，那么如何防止触发多次呢？

我们可以判断 *key* 是否为当前被代理对象 *target* 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 *trigger*。

#### `v-model` 双向绑定的原理是什么？



*v-model* 本质就是 *:value + input* 方法的语法糖。可以通过 *model* 属性的 *prop* 和 *event* 属性来进行自定义。原生的 *v-model*，会根据标签的不同生成不同的事件和属性。

例如:

- *text* 和 *textarea* 元素使用 *value* 属性和 *input* 事件
- *checkbox* 和 *radio* 使用 *checked* 属性和 *change* 事件
- *select* 字段将 *value* 作为 *prop* 并将 *change* 作为事件

以输入框为例，当用户在输入框输入内容时，会触发 *input* 事件，从而更新 *value*。而 *value* 的改变同样会更新视图，这就是 *vue* 中的双向绑定。双向绑定的原理，其实现思路如下:

首先要对数据进行劫持监听，所以我们需要设置一个监听器 *Observer*，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 *Watcher* 看是否需要更新。

因为订阅者是有很多个，所以我们需要有一个消息订阅器 *Dep* 来专门收集这些订阅者，然后在监听器 *Observer* 和订阅者 *Watcher* 之间进行统一管理的。

接着，我们还需要有一个指令解析器 *Compile*，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 *Watcher*，并替换模板数据或者绑定相应的函数，此时当订阅者 *Watcher* 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

因此接下去我们执行以下 *3* 个步骤，实现数据的双向绑定:

1. 实现一个监听器 *Observer*，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者 *Watcher*，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器 *Compile*，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

流程图如下:

#### `vue2.x` 和 `vuex3.x` 渲染器的 `diff` 算法分别说一下？



简单来说，*diff* 算法有以下过程

- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的 *children* 没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心 *diff*)
- 递归比较子节点

正常 *Diff* 两个树的时间复杂度是 *O(n^3)*，但实际情况下我们很少会进行跨层级的移动 *DOM*，所以 *Vue* 将 *Diff* 进行了优化，从*O(n^3) -> O(n)*，只有当新旧 *children* 都为多个子节点时才需要用核心的 *Diff* 算法进行同层级比较。

*Vue2* 的核心 *Diff* 算法采用了双端比较的算法，同时从新旧 *children* 的两端开始进行比较，借助 *key* 值找到可复用的节点，再进行相关操作。相比 *React* 的 *Diff* 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

*Vue3.x* 借鉴了 *ivi* 算法和 *inferno* 算法

在创建 *VNode* 时就确定其类型，以及在 *mount/patch* 的过程中采用位运算来判断一个 *VNode* 的类型，在这个基础之上再配合核心的 *Diff* 算法，使得性能上较 *Vue2.x* 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。

#### `vue` 组件的参数传递

- 解释一下父组件与子组件传值实现过程
- 非父子组件的数据传递，兄弟组件传值是如何实现的



#### 解释一下父组件与子组件传值实现过程

- 父组件传给子组件: 子组件通过 *props* 方法接受数据
- 子组件传给父组件: 使用自定义事件，自组件通过 *$emit* 方法触发父组件的方法来传递参数

#### 非父子组件的数据传递，兄弟组件传值是如何实现的

*eventBus*，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。

此外，总结 *vue* 中的组件通信方式，常见使用场景可以分为三类:

- 父子通信:  
  - 父向子传递数据是通过 *props* ，子向父是通过 *$emit / $on*
  - *$emit / $bus*
  - *vuex*
  - 通过父链 / 子链也可以通信（ *$parent / $children* ）
  - *ref* 也可以访问组件实例
  - *v-model*
  - .*sync* 修饰符
- 兄弟通信:  
  - *$emit / $bus*
  - *vuex*
- 跨级通信:  
  - *$emit / $bus*
  - *vuex*
  - *provide / inject API*
  - *attrs/attrs/attrs/listeners*

#### `Vue` 的路由实现

- 解释 *hash* 模式和 *history* 模式的实现原理
- 说一下*router∗与∗router` 与 `router∗与∗route* 的区别
- *vueRouter* 有哪几种导航守卫？
- 解释一下 *vueRouter* 的完整的导航解析流程是什么

- *

#### vue组件中data为什么必须是一个函数？

因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。  

组建中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。  

#### 渐进式框架的理解

主张最少；可以根据不同的需求选择不同的层级；  

#### Vue中双向数据绑定是如何实现的？  

vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；  
核心: 关于VUE双向数据绑定，其核心是 Object.defineProperty()方法。  

#### 单页面应用和多页面应用区别及优缺点

单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。  
多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新  
单页面的优点:
用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。  
单页面缺点:
不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。  

#### assets和static的区别

相同点: assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点  
不相同点: assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html一同上传至服务器。static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是static中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于assets中打包后的文件提交较大点。在服务器中就会占据更大的空间。  
建议: 将项目中template需要的样式文件js文件等都可以放置在assets中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。  

#### vue常用的修饰符

.stop: 等同于JavaScript中的event.stopPropagation()，防止事件冒泡；  
.prevent: 等同于JavaScript中的event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；  
.capture: 与事件冒泡的方向相反，事件捕获由外到内；  
.self: 只会触发自己范围内的事件，不包含子元素；  
.once: 只会触发一次。  

#### vue的两个核心点

数据驱动、组件系统  
数据驱动: ViewModel，保证数据和视图的一致性。  
组件系统: 应用类UI可以看作全部是由组件树构成的。  

#### vue和jQuery的区别

jQuery是使用选择器（\$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容: $("lable").val();,它还是依赖DOM元素的值。  
Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。  

#### 如何让 `CSS` 值在当前的组件中起作用

在 *vue* 文件中的 *style* 标签上，有一个特殊的属性: *scoped*。当一个 style 标签拥有 *scoped* 属性时，它的 *CSS* 样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有 *style* 标签全部加上了 *scoped*，相当于实现了样式的模块化。

#### `scoped` 的实现原理

*vue* 中的 *scoped* 属性的效果主要通过 *PostCSS* 转译实现的。*PostCSS* 给一个组件中的所有 *DOM* 添加了一个独一无二的动态属性，然后，给 *CSS* 选择器额外添加一个对应的属性选择器来选择该组件中 *DOM*，这种做法使得样式只作用于含有该属性的 *DOM*，即组件内部 *DOM*。

例如:

转译前



> ```js
> <template>
> <div class="example">hi</div>
> </template>
> 
> <style scoped>
> .example {
> color: red;
> }
> </style>
> ```
>
> 

转译后:

> ```js
> <template>
> <div class="example" data-v-5558831a>hi</div>
> </template>
> 
> <style>
>  .example[data-v-5558831a] {
>   color: red;
>  }
> </style>
> ```
>
> 

#### `keep-alive` 相关

- keep-alive的实现原理是什么
- 与keep-alive相关的生命周期函数是什么，什么场景下会进行使用
- keep-alive的常用属性有哪些

keep-alive 组件是 vue 的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，一方面能够避免创建组件带来的开销，另一方面可以保留组件的状态。

keep-alive 具有 include 和 exclude 属性，通过它们可以控制哪些组件进入缓存。另外它还提供了 max 属性，通过它可以设置最大缓存数，当缓存的实例超过该数时，vue 会移除最久没有使用的组件缓存。

受keep-alive的影响，其内部所有嵌套的组件都具有两个生命周期钩子函数，分别是 activated 和 deactivated，它们分别在组件激活和失活时触发。第一次 activated 触发是在 mounted 之后

在具体的实现上，keep-alive 在内部维护了一个 key 数组和一个缓存对象

```js
// keep-alive 内部的声明周期函数
created () {
  this.cache = Object.create(null)
  this.keys = []
}
```

key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值

cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM

在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。

当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素。

#### 说一下 `Vue SSR` 的实现原理

- *app.js* 作为客户端与服务端的公用入口，导出 *Vue* 根实例，供客户端 *entry* 与服务端 *entry* 使用。客户端 *entry* 主要作用挂载到 *DOM* 上，服务端 *entry* 除了创建和返回实例，还需要进行路由匹配与数据预获取。
- *webpack* 为客服端打包一个 *ClientBundle*，为服务端打包一个 *ServerBundle*。
- 服务器接收请求时，会根据 *url*，加载相应组件，获取和解析异步数据，创建一个读取 *Server Bundle* 的 *BundleRenderer*，然后生成 *html* 发送给客户端。
- 客户端混合，客户端收到从服务端传来的 *DOM* 与自己的生成的 *DOM* 进行对比，把不相同的 *DOM* 激活，使其可以能够响应后续变化，这个过程称为客户端激活（也就是转换为单页应用）。为确保混合成功，客户 端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 *store* 里，这样，在客户端挂载到 *DOM* 之前，可以直接从 *store* 里取数据。首屏的动态数据通过 *window.*`INITIAL_STATE`** 发送到客户端
- *VueSSR* 的原理，主要就是通过 *vue-server-renderer* 把 *Vue* 的组件输出成一个完整 *HTML*，输出到客户端，到达客户端后重新展开为一个单页应用。

#### 说一下 `Vue complier` 的实现原理是什么样的？

在使用 vue 的时候，我们有两种方式来创建我们的 HTML 页面，第一种情况，也是大多情况下，我们会使用模板 template  的方式，因为这更易读易懂也是官方推荐的方法；第二种情况是使用 render 函数来生成 HTML，它比 template 更接近最终结果。

complier 的主要作用是解析模板，生成渲染模板的 *render*， 而 *render* 的作用主要是为了生成 *VNode*

complier 主要分为 3 大块:

- parse: 接受 template 原始模板，按着模板的节点和数据生成对应的 ast
- optimize: 遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能
- generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数

#### `vue` 如何快速定位那个组件出现性能问题的

⽤ *timeline* ⼯具。 通过 *timeline* 来查看每个函数的调⽤时常，定位出哪个函数的问题，从⽽能判断哪个组件出了问题。

#### `Proxy` 相比 `defineProperty` 的优势在哪里

*Vue3.x* 改用 *Proxy* 替代 *Object.defineProperty*

原因在于 *Object.defineProperty* 本身存在的一些问题:

- *Object.defineProperty* 只能劫持对象属性的 *getter* 和 *setter* 方法。
- *Object.definedProperty* 不支持数组(可以监听数组,不过数组方法无法监听自己重写)，更准确的说是不支持数组的各种 *API*(所以 *Vue* 重写了数组方法。

而相比 *Object.defineProperty*，*Proxy* 的优点在于:

- *Proxy* 是直接代理劫持整个对象。
- *Proxy* 可以直接监听对象和数组的变化，并且有多达 *13* 种拦截方法。

目前，*Object.definedProperty* 唯一比 *Proxy* 好的一点就是兼容性，不过 *Proxy* 新标准也受到浏览器厂商重点持续的性能优化当中。

#### `Vue` 与 `Angular` 以及 `React` 的区别是什么？

这种题目是开放性题目，一般是面试过程中面试官口头来提问，不太可能出现在笔试试卷里面。

关于 *Vue* 和其他框架的不同，官方专门写了一篇文档，从性能、体积、灵活性等多个方面来进行了说明。

详细可以参阅: *https://cn.vuejs.org/v2/guide/comparison.html*

建议面试前通读一遍该篇文档，然后进行适当的总结。

#### `scoped` 是如何实现样式穿透的？

首先说一下什么场景下需要 *scoped* 样式穿透。

在很多项目中，会出现这么一种情况，即: 引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除 *scoped* 属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透 *scoped*。

有三种常用的方法来实现样式穿透。

**方法一**

使用 *::v-deep* 操作符( >>> 的别名)

如果希望 *scoped* 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 >>> 操作符:

> ```js
><style scoped>
>   .a >>> .b { /* ... */ }
></style>
> ```

上述代码将会编译成:

> ```js
>.a[data-v-f3f3eg9] .b { /* ... */ }
> ```

后面的类名没有 *data* 属性，所以能选到子组件里面的类名。

有些像 *Sass* 之类的预处理器无法正确解析 >>>，所以需要使用 *::v-deep* 操作符来代替。

**方法二**

定义一个含有 *scoped* 属性的 *style* 标签之外，再定义一个不含有 *scoped* 属性的 *style* 标签，即在一个 *vue* 组件中定义一个全局的 *style* 标签，一个含有作用域的 *style* 标签:

> ```html
><style>
>   /* global styles */
></style>
> 
><style scoped>
>   /* local styles */
></style>
> ```

此时，我们只需要将修改第三方样式的 *css* 写在第一个 *style* 中即可。

**方法三**

上面的方法一需要单独书写一个不含有 *scoped* 属性的 *style* 标签，可能会造成全局样式的污染。

更推荐的方式是在组件的外层 *DOM* 上添加唯一的 *class* 来区分不同组件，在书写样式时就可以正常针对针对这部分 *DOM* 书写样式。

####  

#### 说一下你知道的 `vue` 修饰符都有哪些？

在 *vue* 中修饰符可以分为 *3* 类:

- 事件修饰符
- 按键修饰符
- 表单修饰符

**事件修饰符**

在事件处理程序中调用 *event.preventDefault* 或 *event.stopPropagation* 方法是非常常见的需求。尽管可以在 *methods* 中轻松实现这点，但更好的方式是: *methods* 只有纯粹的数据逻辑，而不是去处理 *DOM* 事件细节。

为了解决这个问题，*vue* 为 *v-on* 提供了事件修饰符。通过由点 *.* 表示的指令后缀来调用修饰符。

常见的事件修饰符如下:

- *.stop*: 阻止冒泡。
- *.prevent*: 阻止默认事件。
- *.capture*: 使用事件捕获模式。
- *.self*: 只在当前元素本身触发。
- *.once*: 只触发一次。
- *.passive*: 默认行为将会立即触发。

**按键修饰符**

除了事件修饰符以外，在 *vue* 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。

- .*left*: 左键
- .*right*: 右键
- .*middle*: 滚轮
- .*enter*: 回车
- .*tab*: 制表键
- .*delete*: 捕获 “删除” 和 “退格” 键
- .*esc*: 返回
- .*space*: 空格
- .*up*: 上
- .*down*: 下
- .*left*: 左
- .*right*: 右
- .*ctrl*: *ctrl* 键
- .*alt*: *alt* 键
- .*shift*: *shift* 键
- .*meta*: *meta* 键

**表单修饰符**

*vue* 同样也为表单控件也提供了修饰符，常见的有 *.lazy*、*.number* 和 *.trim*。

- .*lazy*: 在文本框失去焦点时才会渲染
- .*number*: 将文本框中所输入的内容转换为number类型
- .*trim*: 可以自动过滤输入首尾的空格

#### 如何实现 `vue` 项目中的性能优化？

**编码阶段**

- 尽量减少 *data* 中的数据，*data* 中的数据都会增加 *getter* 和 *setter*，会收集对应的 *watcher*
- *v-if* 和 *v-for* 不能连用
- 如果需要使用 *v-for* 给每项元素绑定事件时使用事件代理
- *SPA* 页面采用 *keep-alive* 缓存组件
- 在更多的情况下，使用 *v-if* 替代 *v-show*
- *key* 保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

***SEO` 优化**

- 预渲染
- 服务端渲染 *SSR*

**打包优化**

- 压缩代码
- *Tree Shaking/Scope Hoisting*
- 使用 *cdn* 加载第三方模块
- 多线程打包 *happypack*
- *splitChunks* 抽离公共文件
- *sourceMap* 优化

**用户体验**

- 骨架屏
- *PWA*

还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 *gzip* 压缩等。

#### `vue` 中的 `spa` 应用如何优化首屏加载速度?

优化首屏加载可以从这几个方面开始:

- 请求优化: CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
- 缓存: 将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验
- gzip: 开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。
- http2: 如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而  http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。
- 懒加载: 当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件
- 预渲染: 由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化
- 合理使用第三方库: 对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积
- 使用可视化工具分析打包后的模块体积: webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化
- 提高代码使用率: 利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程
- 封装: 构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化
- 图片懒加载: 使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验
- 使用 svg 图标: 相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求
- 压缩图片: 可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片

#### 移动端如何实现一个比较友好的 `header` 组件

*Header* 一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过 *vue props*的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过 *vue slot* 插槽的方式对外暴露以实现多样化，同时也可以提供 *default slot* 默认插槽来统一页面风格。

#### 既然 `Vue` 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 `DOM` 进行 `diff` 监测差异 ？

现代前端框架有两种方式侦测变化，一种是 *pull*，一种是 *push*。

***pull***

其代表为 *React*，我们可以回忆一下 *React* 是如何侦测到变化的。

我们通常会用 *setState API* 显式更新,然后 *React* 会进行一层层的 *Virtual Dom Diff* 操作找出差异，然后 *Patch* 到 *DOM* 上，*React* 从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的 *Diff* 操作查找「哪发生变化了」，另外一个代表就是 *Angular* 的脏检查操作。

***push***

*Vue* 的响应式系统则是 *push* 的代表，当 *Vue* 程序初始化的时候就会对数据 *data* 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知，因此 *Vue* 是一开始就知道是「在哪发生变化了」

但是这又会产生一个问题，通常绑定一个数据就需要一个 *Watcher*，一但我们的绑定细粒度过高就会产生大量的 *Watcher*，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 *Vue* 的设计是选择中等细粒度的方案，在组件级别进行 *push* 侦测的方式，也就是那套响应式系统。

通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行 *Virtual Dom Diff* 获取更加具体的差异，而 *Virtual Dom Diff* 则是 *pull* 操作，*Vue* 是 *push + pull* 结合的方式进行变化侦测的。

#### `Vue` 为什么没有类似于 `React` 中 `shouldComponentUpdate` 的生命周期？

根本原因是 *Vue* 与 *React* 的变化侦测方式有所不同

*React* 是 *pull* 的方式侦测变化，当 *React* 知道发生变化后，会使用 *Virtual Dom Diff* 进行差异检测,但是很多组件实际上是肯定不会发生变化的，这个时候需要用 *shouldComponentUpdate* 进行手动操作来减少 *diff*，从而提高程序整体的性能。

*Vue* 是 *pull+push* 的方式侦测变化的，在一开始就知道那个组件发生了变化，因此在 *push* 的阶段并不需要手动控制 *diff*，而组件内部采用的 *diff* 方式实际上是可以引入类似于 *shouldComponentUpdate* 相关生命周期的，但是通常合理大小的组件不会有过量的 *diff*，手动优化的价值有限，因此目前 *Vue* 并没有考虑引入 *shouldComponentUpdate* 这种手动优化的生命周期。

-

#### 说一下你对 `vue` 事件绑定原理的理解？

*vue* 中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。

原生的事件绑定在普通元素上是通过 *@click* 进行绑定，在组件上是通过 *@click.native* 进行绑定，组件中的 *nativeOn* 是等价于 on 的。组件的事件绑定的 @click 是 vue 中自定义的 $on 方法来实现的，必须有 $emit 才可以触发。

**原生事件绑定原理**

在 runtime下的patch.js中createPatchFunction执行了之后再赋值给patch。

createPatchFunction方法有两个参数，分别是nodeOps存放操作dom节点的方法和modules，modules是有两个数组拼接起来的，modules拼接完的数组中有一个元素就是events，事件添加就发生在这里。

events元素关联的就是events.js文件，在events中有一个updateDOMListeners方法，在events文件的结尾导出了一个对象，然后对象有一个属性叫做create，这个属性关联的就是updateDOMListeners方法。

在执行createPatchFunction方法时，就会将这两个参数传入，在createPatchFunction方法中接收了一个参数backend，在该方法中一开始进行backend的解构，就是上面的nodeOps和modules参数，解构完之后进入for循环。

在createPatchFunction开头定义了一个cbs对象。for循环遍历一个叫hooks的数组。hooks是文件一开头定义的一个数组，其中包括有create，for循环就是在cbs上定义一系列和hooks元素相同的属性，然后键值是一个数组，然后数组内容是modules里面的一些内容。这时就把events文件中导出来的create属性放在了cbs上。

当我们进入首次渲染的时候，会执行到patch函数里面的createElm方法，这个方法中就会调用invokeCreateHooks函数，用来处理事件系统，这里就是真正准备进行原生事件绑定的入口。invokeCreateHooks方法中，遍历了cbs.create数组里面的内容。然后把cbs.create里面的函数全部都执行一次，在cbs.create其中一个函数就是updateDOMListeners。

updateDOMListeners就是用来添加事件的方法，在这方法中会根据vnode判断是否有定义一个点击事件。如果没有点击事件就return。有的话就继续执行，给on进行赋值，然后进行一些赋值操作，将vnode.elm赋值给target，elm这个属性就是指向vnode所对应的真实dom节点，这里就是把我们要绑定事件的dom结点进行缓存，接下来执行updateListeners方法。在接下来执行updateListeners方法中调用了一个add的方法，然后在app方法中通过原生addEventListener把事件绑定到dom上。

**组件事件绑定原理**

在组件实例初始化会调用initMixin方法中的Vue.prototype._init，在init函数中，会通过initInternalComponent方法初始化组件信息，将自定义的组件事件放到_parentListeners上，下来就会调用initEvents来初始化组件事件，在initEvents中会实例上添加一个 _event对象，用于保存自定义事件，然后获取到 父组件给  子组件绑定的自定义事件，也就是刚才在初始化组件信息的时候将自定义的组件事件放在了_parentListeners上，这时候vm.$options._parentListeners就是自定义的事件。

最后进行判断，如果有自定义的组件事件就执行updateComponentListeners方法进行事件绑定，在updateComponentListeners方法中会调用updateListeners方法，并传传一个add方法进行执行，这个add方法里就是$on方法。

#### 说一下 `vue` 模版编译的原理是什么

简单说，*Vue* 的编译过程就是将 *template* 转化为 *render* 函数的过程。会经历以下阶段:

- 生成 *AST* 树
- 优化
- *codegen*

首先解析模版，生成 *AST* 语法树(一种用 *JavaScript* 对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。

*Vue* 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 *DOM* 也不会变化。那么优化过程就是深度遍历 *AST* 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。

编译的最后一步是将优化后的 *AST* 树转换为可执行的代码。

可以参阅前面第 *22* 题。

#### `delete` 和 `Vue.delete` 删除数组的区别是什么？

*delete* 只是被删除的元素变成了 *empty/undefined* 其他的元素的键值还是不变。
*Vue.delete* 是直接将元素从数组中完全删除，改变了数组其他元素的键值。

#### `v-on` 可以实现监听多个方法么？

可以监听多个方法。关于监听多个方法提供了几种不同的写法:

> ```html
>写法一: <div v-on="{ 事件类型: 事件处理函数, 事件类型: 事件处理函数 }"></div>
> 写法二: <div @事件类型=“事件处理函数” @事件类型=“事件处理函数”></div>
>写法三: 在一个事件里面书写多个事件处理函数
> <div @事件类型=“事件处理函数1，事件处理函数2”></div>
> 写法四: 在事件处理函数内部调用其他的函数
> ```

示例代码如下:

> ```html
><template>
>   <div>
>    <!-- v-on在vue2.x中测试,以下两种均可-->
>     <button v-on="{ mouseenter: onEnter, mouseleave: onLeave }">
>       鼠标进来1
>     </button>
>     <button @mouseenter="onEnter" @mouseleave="onLeave">鼠标进来2</button>
> 
>     <!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号-->
>     <button @click="a(), b()">点我ab</button>
>    <button @click="one()">点我onetwothree</button>
>   </div>
></template>
> <script>
>   export default {
>     methods: {
>        //这里是es6对象里函数写法
>        a() {
>            console.log("a");
>        },
>        b() {
>         console.log("b");
>        },
>        one() {
>          console.log("one");
>         this.two();
>         this.three();
>       },
>       two() {
>         console.log("two");
>        },
>        three() {
>            console.log("three");
>        },
>        onEnter() {
>            console.log("mouse enter");
>        },
>        onLeave() {
>            console.log("mouse leave");
>          },
>        },
>    };
>  </script>
>    ```

#### `vue` 的数据为什么频繁变化但只会更新一次？

这是因为 *vue* 的 *DOM* 更新是一个异步操作，在数据更新后会首先被 *set* 钩子监听到，但是不会马上执行 *DOM* 更新，而是在下一轮循环中执行更新。

具体实现是 *vue* 中实现了一个 *queue* 队列用于存放本次事件循环中的所有 *watcher* 更新，并且同一个 *watcher* 的更新只会被推入队列一次，并在本轮事件循环的微任务执行结束后执行此更新(*UI Render* 阶段)，这就是 *DOM* 只会更新一次的原因。

这种在缓冲时去除重复数据对于避免不必要的计算和 *DOM* 操作是非常重要的。然后，在下一个的事件循环“*tick*”中，*vue* 刷新队列并执行实际 (已去重的) 工作。*vue* 在内部对异步队列尝试使用原生的 *Promise.then、MutationObserver* 和 *setImmediate*，如果执行环境不支持，则会采用 *setTimeout(fn, 0)* 代替。

#### 说一下 `vue` 中 `computed` 和 `methods` 的区别是什么？

首先从表现形式上面来看， *computed* 和 *methods* 的区别大致有下面 *4* 点:

1. 在使用时，*computed* 当做属性使用，而 *methods* 则当做方法调用
2. *computed* 可以具有 *getter* 和 *setter*，因此可以赋值，而 *methods* 不行
3. *computed* 无法接收多个参数，而 *methods* 可以
4. *computed* 具有缓存，而 *methods* 没有

而如果从底层来看的话， *computed* 和 *methods* 在底层实现上面还有很大的区别。

*vue* 对 *methods* 的处理比较简单，只需要遍历 *methods* 配置中的每个属性，将其对应的函数使用 *bind* 绑定当前组件实例后复制其引用到组件实例中即可

而 *vue* 对 *computed* 的处理会稍微复杂一些。

#### 在 `Vue` 中要获取当前时间你会放到 `computed` 还是 `methods` 里？(抖音直播)**

放在 *computed* 里面。因为 *computed* 只有在它的相关依赖发生改变时才会重新求值。相比而言，方法只要发生重新渲染，*methods* 调用总会执行所有函数。

#### 在给 `vue` 中的元素设置 `key` 值时可以使用 `Math` 的 `random` 方法么？

*random* 是生成随机数，有一定概率多个 *item* 会生成相同的值，不能保证唯一。

如果是根据数据来生成 *item*，数据具有 *id* 属性，那么就可以使用 *id* 来作为 *key*。

如果不是根据数据生成 *item*，那么最好的方式就是使用时间戳来作为 *key*。或者使用诸如 *uuid* 之类的库来生成唯一的 *id*。

#### 插槽与作用域插槽的区别是什么？

插槽的作用是子组件提供了可替换模板，父组件可以更换模板的内容。

作用域插槽给了子组件将数据返给父组件的能力，子组件一样可以复用，同时父组件也可以重新组织内容和样式。

#### `vue` 中相同逻辑如何进行抽离？

可以使用 *vue* 里面的混入（*mixin*）技术。混入（*mixin*）提供了一种非常灵活的方式，来将 *vue* 中相同的业务逻辑进行抽离。

例如:

- 在 *data* 中有很多是公用数据
- 引用封装好的组件也都是一样的
- *methods、watch、computed* 中也都有大量的重复代码

当然这个时候可以将所有的代码重复去写来实现功能，但是我们并不不推荐使用这种方式，无论是工作量、工作效率和后期维护来说都是不建议的，这个时候 *mixin* 就可以大展身手了。

一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。

**混入技术特点**

- 当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。
- 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。
- 值为对象的选项，例如 *methods、components* 和 *directives*，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

#### 如何监听 `pushstate` 和 `replacestate` 的变化呢？

*History.replaceState* 和 *pushState* 不会触发 *popstate* 事件，所以我们可以通过在方法中创建一个新的全局事件来实现 *pushstate* 和 *replacestate* 变化的监听。

具体做法为:

```js
var _wr = function(type) {
  var orig = history[type];
  return function() {
    var rv = orig.apply(this, arguments);
    var e = new Event(type);
    e.arguments = arguments;
    window.dispatchEvent(e);
    return rv;
  };
};
history.pushState = _wr('pushState');
history.replaceState = _wr('replaceState');
```

这样就创建了 *2* 个全新的事件，事件名为 *pushState* 和 *replaceState*，我们就可以在全局监听:

```js
window.addEventListener('replaceState', function(e) {
  console.log('THEY DID IT AGAIN! replaceState 111111');
});
window.addEventListener('pushState', function(e) {
  console.log('THEY DID IT AGAIN! pushState 2222222');
});
```

这样就可以监听到 *pushState* 和 *replaceState* 行为。

#### 说一下 `vue3.0` 是如何变得更快的？

**优化 `Diff` 算法**

相比 *Vue 2*，*Vue 3* 采用了更加优化的渲染策略。去掉不必要的虚拟 *DOM* 树遍历和属性比较，因为这在更新期间往往会产生最大的性能开销。

这里有三个主要的优化:

- 首先，在 *DOM* 树级别。

在没有动态改变节点结构的模板指令（例如 *v-if* 和 *v-for*）的情况下，节点结构保持完全静态。

当更新节点时，不再需要递归遍历 *DOM* 树。所有的动态绑定部分将在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟 *DOM* 的大部分开销。

- 其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。
- 第三，在元素级别。

编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。

例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。

综合起来，这些技术大大改进了渲染更新基准，*Vue 3.0* 有时占用的 *CPU* 时间不到 *Vue 2* 的十分之一。

**体积变小**

重写后的 *Vue* 支持了 *tree-shaking*，像修剪树叶一样把不需要的东西给修剪掉，使 *Vue 3.0* 的体积更小。

需要的模块才会打入到包里，优化后的 *Vue 3.0* 的打包体积只有原来的一半（*13kb*）。哪怕把所有的功能都引入进来也只有 *23kb*，依然比 *Vue 2.x* 更小。像 *keep-alive、transition* 甚至 *v-for* 等功能都可以按需引入。

并且 *Vue 3.0* 优化了打包方法，使得打包后的 *bundle* 的体积也更小。

官方所给出的一份惊艳的数据: 打包大小减少 *41%*，初次渲染快 *55%*，更新快 *133%*，内存使用减少 *54%*。

- 

#### 说一说相比 *vue3.x* 对比 *vue2.x* 变化

1. 源码组织方式变化: 使用 TS 重写
2. 支持 Composition API: 基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）
3. 响应式系统提升: Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化
4. 编译优化: vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容
5. 打包体积优化: 移除了一些不常用的api（inline-template、filter）
6. 生命周期的变化: 使用setup代替了之前的beforeCreate和created
7. Vue3 的 template 模板支持多个根标签
8. Vuex状态管理: 创建实例的方式改变,Vue2为new Store , Vue3为createStore
9. Route 获取页面实例与路由信息: vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例
10. Props 的使用变化: vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props
11. 父子组件传值: vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下

#### `vue` 为什么采用异步渲染

因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染；所以为了性能考虑，*Vue* 会在本轮数据更新后，再去异步更新视图。

异步渲染的原理:

1. 调用 *notify( )* 方法，通知 *watcher* 进行更新操作
2. 依次调用 watcher 的 update 方法
3. 对 watcher 进行去重操作（通过id）放到队列里
4. 执行完后异步清空这个队列，nextTick（flushSchedulerQueue）进行批量更新操作

#### 组件中写 *name* 选项有哪些好处

1. 可以通过名字找到对应的组件（ 递归组件: 组件自身调用自身 ）
2. 可以通过 *name* 属性实现缓存功能（*keep-alive*）
3. 可以通过 *name* 来识别组件（跨级组件通信时非常重要）
4. 使用 *vue-devtools* 调试工具里显示的组见名称是由 *vue* 中组件 *name* 决定的

#### mvvm 框架是什么？

vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。  

### 基础

#### 什么是递归组件？举个例子说明下？

**分析**

递归组件我们用的比较少，但是在`Tree`、`Menu`这类组件中会被用到。

**体验**

组件通过组件名称引用它自己，这种情况就是递归组件

```
<template>
  <li>
 <div> {{ model.name }}</div>
 <ul v-show="isOpen" v-if="isFolder">
<!-- 注意这里: 组件递归渲染了它自己 -->
<TreeItem
  class="item"
  v-for="model in model.children"
  :model="model">
</TreeItem>
 </ul>
  </li>
<script>
export default {
  name: 'TreeItem',
  // ...
}
</script>
复制代码
```

**回答范例**

1. 如果某个组件通过组件名称引用它自己，这种情况就是递归组件。
2. 实际开发中类似`Tree`、`Menu`这类组件，它们的节点往往包含子节点，子节点结构和父节点往往是相同的。这类组件的数据往往也是树形结构，这种都是使用递归组件的典型场景。
3. 使用递归组件时，由于我们并未也不能在组件内部导入它自己，所以设置组件`name`属性，用来查找组件定义，如果使用`SFC`，则可以通过`SFC`文件名推断。组件内部通常也要有递归结束条件，比如`model.children`这样的判断。
4. 查看生成渲染函数可知，递归组件查找时会传递一个布尔值给`resolveComponent`，这样实际获取的组件就是当前组件本身

**原理**

递归组件编译结果中，获取组件时会传递一个标识符 `_resolveComponent("Comp", true)`

```
const _component_Comp = _resolveComponent("Comp", true)
复制代码
```

就是在传递`maybeSelfReference`

```
export function resolveComponent(
  name: string,
  maybeSelfReference?: boolean
): ConcreteComponent | string {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name
}
复制代码
```

`resolveAsset`中最终返回的是组件自身:

```
if (!res && maybeSelfReference) {
 // fallback to implicit self-reference
 return Component
}
复制代码
```

#### 说说你对slot的理解？slot使用场景有哪些

**slot是什么

在HTML中 `slot` 元素 ，作为 `Web Components` 技术套件的一部分，是Web组件内的一个占位符

该占位符可以在后期使用自己的标记语言填充

举个栗子

```
<template id="element-details-template">
  <slot name="element-name">Slot template</slot>
</template>
<element-details>
  <span slot="element-name">1</span>
</element-details>
<element-details>
  <span slot="element-name">2</span>
</element-details>
```

`template`不会展示到页面中，需要用先获取它的引用，然后添加到`DOM`中，

```
customElements.define('element-details',
  class extends HTMLElement {
 constructor() {
super();
const template = document
  .getElementById('element-details-template')
  .content;
const shadowRoot = this.attachShadow({mode: 'open'})
  .appendChild(template.cloneNode(true));
  }
})
```

在`Vue`中的概念也是如此

`Slot` 艺名插槽，花名“占坑”，我们可以理解为`solt`在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中`slot`位置），作为承载分发内容的出口

**使用场景**

通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理

如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情

通过`slot`插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用

比如布局组件、表格列、下拉选、弹框显示内容等

#### ref和reactive异同

这是`Vue3`数据响应式中非常重要的两个概念，跟我们写代码关系也很大

```
const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

const obj = reactive({ count: 0 })
obj.count++
复制代码
```

- `ref`接收内部值（`inner value`）返回响应式`Ref`对象，`reactive`返回响应式代理对象
- 从定义上看`ref`通常用于处理单值的响应式，`reactive`用于处理对象类型的数据响应式
- 两者均是用于构造响应式数据，但是`ref`主要解决原始值的响应式问题
- `ref`返回的响应式数据在JS中使用需要加上`.value`才能访问其值，在视图中使用会自动脱`ref`，不需要`.value`；`ref`可以接收对象或数组等非原始值，但内部依然是`reactive`实现响应式；`reactive`内部如果接收`Re`f对象会自动脱`ref`；使用展开运算符(`...`)展开`reactive`返回的响应式对象会使其失去响应性，可以结合`toRefs()`将值转换为`Ref`对象之后再展开。
- `reactive`内部使用`Proxy`代理传入对象并拦截该对象各种操作，从而实现响应式。`ref`内部封装一个`RefImpl`类，并设置`get value/set value`，拦截用户对值的访问，从而实现响应式

#### 为什么要使用异步组件

1. 节省打包出的结果，异步组件分开打包，采用`jsonp`的方式进行加载，有效解决文件过大的问题。
2. 核心就是包组件定义变成一个函数，依赖`import()` 语法，可以实现文件的分割加载。

```
components:{ 
  AddCustomerSchedule:(resolve)=>import("../components/AddCustomer") // require([]) 
}
复制代码
```

原理

```
export function ( Ctor: Class<Component> | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array<VNode>, tag?: string ): VNode | Array<VNode> | void { 
 // async component 
 let asyncFactory 
 if (isUndef(Ctor.cid)) { 
  asyncFactory = Ctor 
  Ctor = resolveAsyncComponent(asyncFactory, baseCtor) // 默认调用此函数时返回 undefiend 
  // 第二次渲染时Ctor不为undefined 
  if (Ctor === undefined) { 
return createAsyncPlaceholder( // 渲染占位符 空虚拟节点 
 asyncFactory, 
 data, 
 context, 
 children, 
 tag 
) 
  } 
 } 
}
function resolveAsyncComponent ( factory: Function, baseCtor: Class<Component> ): Class<Component> | void { 
 if (isDef(factory.resolved)) { 
  // 3.在次渲染时可以拿到获取的最新组件 
  return factory.resolved 
 }
 const resolve = once((res: Object | Class<Component>) => { 
  factory.resolved = ensureCtor(res, baseCtor) 
  if (!sync) { 
forceRender(true) //2. 强制更新视图重新渲染 
  } else { 
owners.length = 0 
  } 
 })
 const reject = once(reason => { 
  if (isDef(factory.errorComp)) { 
factory.error = true forceRender(true) 
  } 
 })
 const res = factory(resolve, reject)// 1.将resolve方法和reject方法传入，用户调用 resolve方法后 
 sync = false 
 return factory.resolved 
}
复制代码
```

-

参考 [前端进阶面试题详细解答](https://link.juejin.cn/?target=https%3A%2F%2Fthoughts.teambition.com%2Fshare%2F638dd9f64d2d2a0042e50fb4 "https://thoughts.teambition.com/share/638dd9f64d2d2a0042e50fb4")

#### 怎么实现路由懒加载呢

这是一道应用题。当打包应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应组件，这样就会更加高效

```
// 将
// import UserDetails from './views/UserDetails'
// 替换为
const UserDetails = () => import('./views/UserDetails')

const router = createRouter({
  // ...
  routes: [{ path: '/users/:id', component: UserDetails }],
})
复制代码
```

**回答范例**

1. 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。利用路由懒加载我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样会更加高效，是一种优化手段
2. 一般来说，对所有的**路由都使用动态导入**是个好主意
3. 给`component`选项配置一个返回 `Promise` 组件的函数就可以定义懒加载路由。例如: `{ path: '/users/:id', component: () => import('./views/UserDetails') }`
4. 结合注释 `() => import(/* webpackChunkName: "group-user" */ './UserDetails.vue')` 可以做`webpack`代码分块

#### 组件中写name属性的好处

> 可以标识组件的具体名称方便调试和查找对应属性

```
// 源码位置 src/core/global-api/extend.js

// enable recursive self-lookup
if (name) { 
 Sub.options.components[name] = Sub // 记录自己 在组件中递归自己  -> jsx
}
复制代码
```

#### Vue组件为什么只能有一个根元素

`vue3`中没有问题

```js
Vue.createApp({
  components: {
    comp: {
      template: `
<div>root1</div>
<div>root2</div>
`
    }
  }
}).mount('#app')
```

1. `vue2`中组件确实只能有一个根，但`vue3`中组件已经可以多根节点了。
2. 之所以需要这样是因为`vdom`是一颗单根树形结构，`patch`方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为一个`vdom`
3. `vue3`中之所以可以写多个根节点，是因为引入了`Fragment`的概念，这是一个抽象的节点，如果发现组件是多根的，就创建一个`Fragment`节点，把多个根节点作为它的`children`。将来`patch`的时候，如果发现是一个`Fragment`节点，则直接遍历`children`创建或更新

#### Vue 修饰符有哪些

**vue中修饰符分为以下五种**

- 表单修饰符
- 事件修饰符
- 鼠标按键修饰符
- 键值修饰符
- `v-bind`修饰符

**1\. 表单修饰符**

在我们填写表单的时候用得最多的是`input`标签，指令用得最多的是`v-model`

关于表单的修饰符有如下:

- `lazy`

在我们填完信息，光标离开标签的时候，才会将值赋予给`value`，也就是在`change`事件之后再进行信息同步

```
<input type="text" v-model.lazy="value">
<p>{{value}}</p>
复制代码
```

- `trim`

自动过滤用户输入的首空格字符，而中间的空格不会过滤

```
<input type="text" v-model.trim="value">
复制代码
```

- `number`

自动将用户的输入值转为数值类型，但如果这个值无法被`parseFloat`解析，则会返回原来的值

```
<input v-model.number="age" type="number">
复制代码
```

**2\. 事件修饰符**

事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符

- `.stop` 阻止了事件冒泡，相当于调用了`event.stopPropagation`方法

```
<div @click="shout(2)">
  <button @click.stop="shout(1)">ok</button>
</div>
//只输出1
复制代码
```

- `.prevent` 阻止了事件的默认行为，相当于调用了`event.preventDefault`方法

```
<form v-on:submit.prevent="onSubmit"></form>
复制代码
```

- `.capture` 使用事件捕获模式，使事件触发从包含这个元素的顶层开始往下触发

```
<div @click.capture="shout(1)">
 obj1
<div @click.capture="shout(2)">
 obj2
<div @click="shout(3)">
 obj3
<div @click="shout(4)">
 obj4
</div>
</div>
</div>
</div>
// 输出结构: 1 2 4 3 
复制代码
```

- `.self` 只当在 `event.target` 是当前元素自身时触发处理函数

```
<div v-on:click.self="doThat">...</div>
复制代码
```

> 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `v-on:click.prevent.self` 会阻止所有的点击，而 `v-on:click.self.prevent` 只会阻止对元素自身的点击

- `.once` 绑定了事件以后只能触发一次，第二次就不会触发

```
<button @click.once="shout(1)">ok</button>
复制代码
```

- `.passive` 告诉浏览器你不想阻止事件的默认行为

在移动端，当我们在监听元素滚动事件的时候，会一直触发`onscroll`事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给`onscroll`事件整了一个`.lazy`修饰符

```
<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
复制代码
```

> - 不要把 `.passive` 和 `.prevent` 一起使用,因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。
> - `passive` 会告诉浏览器你不想阻止事件的默认行为

- `native` 让组件变成像`html`内置标签那样监听根元素的原生事件，否则组件上使用 `v-on` 只会监听自定义事件

```
<my-component v-on:click.native="doSomething"></my-component>

<!-- 使用.native修饰符来操作普通HTML标签是会令事件失效的 -->
复制代码
```

**3\. 鼠标按钮修饰符**

鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下:

- `.left` 左键点击
- `.right` 右键点击
- `.middle` 中键点击

```
<button @click.left="shout(1)">ok</button>
<button @click.right="shout(1)">ok</button>
<button @click.middle="shout(1)">ok</button>
复制代码
```

**4\. 键盘事件的修饰符**

键盘修饰符是用来修饰键盘事件（`onkeyup`，`onkeydown`）的，有如下:

`keyCode`存在很多，但vue为我们提供了别名，分为以下两种:

- **普通键** （`enter`、`tab`、`delete`、`space`、`esc`、`up`、`down`、`left`、`right`...）
- **系统修饰键** （`ctrl`、`alt`、`meta`、`shift`...）

```
<!-- 只有按键为keyCode的时候才触发 -->
<input type="text" @keyup.keyCode="shout()">
复制代码
```

还可以通过以下方式自定义一些全局的键盘码别名

```
Vue.config.keyCodes.f2 = 113
复制代码
```

**5\. v-bind修饰符**

`v-bind`修饰符主要是为属性进行操作，用来分别有如下:

- **async** 能对`props`进行一个双向绑定

```
//父组件
<comp :myMessage.sync="bar"></comp> 
//子组件
this.$emit('update:myMessage',params);
复制代码
```

以上这种方法相当于以下的简写

```
//父亲组件
<comp :myMessage="bar" @update:myMessage="func"></comp>
func(e){
 this.bar = e;
}

//子组件js
func2(){
  this.$emit('update:myMessage',params);
}
复制代码
```

使用`async`需要注意以下两点:

- 使用`sync`的时候，子组件传递的事件名格式必须为`update:value`，其中`value`必须与子组件中`props`中声明的名称完全一致
- 注意带有 `.sync` 修饰符的 `v-bind` 不能和表达式一起使用
- **prop** 设置自定义标签属性，避免暴露数据，防止污染HTML结构

```
<input id="uid" title="title1" value="1" :index.prop="index">
复制代码
```

- **camel** 将命名变为驼峰命名法，如将`view-Box`属性名转换为 `viewBox`

```
<svg :viewBox="viewBox"></svg>
复制代码
```

**应用场景**

根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景:

- `.stop`: 阻止事件冒泡
- `.native`: 绑定原生事件
- `.once`: 事件只执行一次
- `.self` : 将事件绑定在自身身上，相当于阻止事件冒泡
- `.prevent`: 阻止默认事件
- `.caption`: 用于事件捕获
- `.once`: 只触发一次
- `.keyCode`: 监听特定键盘按下
- `.right`: 右键

#### Vue组件之间通信方式有哪些

> Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。 **Vue 组件间通信只要指以下 3 类通信** : `父子组件通信`、`隔代组件通信`、`兄弟组件通信`，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信

**组件传参的各种方式**

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd4bcff5d2fb457880342449d2309caf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**组件通信常用方式有以下几种**

- `props / $emit` **适用 父子组件通信**
  - 父组件向子组件传递数据是通过 `prop` 传递的，子组件传递数据给父组件是通过`$emit` 触发事件来做到的
- `ref` 与 `$parent / $children(vue3废弃)` **适用 父子组件通信**
  - `ref`: 如果在普通的 `DOM` 元素上使用，引用指向的就是 `DOM` 元素；如果用在子组件上，引用就指向组件实例
  - `$parent / $children`: 访问访问父组件的属性或方法 / 访问子组件的属性或方法
- `EventBus （$emit / $on）` **适用于 父子、隔代、兄弟组件通信**
  - 这种方法通过一个空的 `Vue` 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件
- `$attrs / $listeners(vue3废弃)` **适用于 隔代组件通信**
  - `$attrs`: 包含了父作用域中不被 `prop` 所识别 (且获取) 的特性绑定 ( `class` 和 `style` 除外 )。当一个组件没有声明任何 `prop`时，这里会包含所有父作用域的绑定 ( `class` 和 `style` 除外 )，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 `inheritAttrs` 选项一起使用
  - `$listeners`: 包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件
- `provide / inject` **适用于 隔代组件通信**
  - 祖先组件中通过 `provider` 来提供变量，然后在子孙组件中通过 `inject` 来注入变量。 `provide / inject` API 主要解决了跨级组件间的通信问题， **不过它的使用场景，主要是子组件获取上级组件的状态** ，跨级组件间建立了一种主动提供与依赖注入的关系
- `$root` **适用于 隔代组件通信** 访问根组件中的属性或方法，是根组件，不是父组件。`$root`只对根组件有用
- `Vuex` **适用于 父子、隔代、兄弟组件通信**
  - `Vuex` 是一个专为 `Vue.js` 应用程序开发的状态管理模式。每一个 `Vuex` 应用的核心就是 `store`（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( `state` )
  - `Vuex` 的状态存储是响应式的。当 `Vue` 组件从 `store` 中读取状态的时候，若 `store` 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
  - 改变 `store` 中的状态的唯一途径就是显式地提交 (`commit`) `mutation`。这样使得我们可以方便地跟踪每一个状态的变化。

**根据组件之间关系讨论组件通信最为清晰有效**

- 父子组件: `props`/`$emit`/`$parent`/`ref`
- 兄弟组件: `$parent`/`eventbus`/`vuex`
- 跨层级关系: `eventbus`/`vuex`/`provide+inject`/`$attrs + $listeners`/`$root`

> 下面演示组件之间通讯三种情况: 父传子、子传父、兄弟组件之间的通讯

**1\. 父子组件通信**

> 使用`props`，父组件可以使用`props`向子组件传递数据。

父组件`vue`模板`father.vue`:

```
<template>
  <child :msg="message"></child>
</template>

<script>
import child from './child.vue';
export default {
  components: {
 child
  },
  data () {
 return {
message: 'father message';
 }
  }
}
</script>
复制代码
```

子组件`vue`模板`child.vue`:

```
<template>
 <div>{{msg}}</div>
</template>

<script>
export default {
  props: {
 msg: {
type: String,
required: true
 }
  }
}
</script>
复制代码
```

**回调函数（callBack）**

父传子: 将父组件里定义的`method`作为`props`传入子组件

```
// 父组件Parent.vue: 
<Child :changeMsgFn="changeMessage">
methods: {
 changeMessage(){
  this.message = 'test'
 }
}
复制代码
```

```
// 子组件Child.vue: 
<button @click="changeMsgFn">
props:['changeMsgFn']
复制代码
```

**子组件向父组件通信**

> 父组件向子组件传递事件方法，子组件通过`$emit`触发事件，回调给父组件

父组件`vue`模板`father.vue`:

```
<template>
 <child @msgFunc="func"></child>
</template>

<script>
import child from './child.vue';
export default {
 components: {
  child
 },
 methods: {
  func (msg) {
console.log(msg);
  }
 }
}
</script>
复制代码
```

子组件`vue`模板`child.vue`:

```
<template>
 <button @click="handleClick">点我</button>
</template>

<script>
export default {
 props: {
  msg: {
type: String,
required: true
  }
 },
 methods () {
  handleClick () {
 //........
 this.$emit('msgFunc');
  }
 }
}
</script>
复制代码
```

**2\. provide / inject 跨级访问祖先组件的数据**

父组件通过使用`provide(){return{}}`提供需要传递的数据

```
export default {
  data() {
 return {
title: '我是父组件',
name: 'poetry'
 }
  },
  methods: {
 say() {
alert(1)
 }
  },
  // provide属性 能够为后面的后代组件/嵌套的组件提供所需要的变量和方法
  provide() {
 return {
message: '我是祖先组件提供的数据',
name: this.name, // 传递属性
say: this.say
 }
  }
}
复制代码
```

子组件通过使用`inject:[“参数1”,”参数2”,…]`接收父组件传递的参数

```
<template>
  <p>曾孙组件</p>
  <p>{{message}}</p>
</template>
<script>
export default {
  // inject 注入/接收祖先组件传递的所需要的数据即可 
  //接收到的数据 变量 跟data里面的变量一样 可以直接绑定到页面 {{}}
  inject: [ "message","say"],
  mounted() {
 this.say();
  },
};
</script>
复制代码
```

**3\. parent+parent + children 获取父组件实例和子组件实例的集合**

- `this.$parent` 可以直接访问该组件的父实例或组件
- 父组件也可以通过 `this.$children` 访问它所有的子组件；需要注意 `$children` 并不保证顺序，也不是响应式的

```
<!-- parent.vue -->
<template>
<div>
  <child1></child1>
  <child2></child2> 
  <button @click="clickChild">$children方式获取子组件值</button>
</div>
</template>
<script>
import child1 from './child1'
import child2 from './child2'
export default {
  data(){
 return {
total: 108
 }
  },
  components: {
 child1,
 child2  
  },
  methods: {
 funa(e){
console.log("index",e)
 },
 clickChild(){
console.log(this.$children[0].msg);
console.log(this.$children[1].msg);
 }
  }
}
</script>
复制代码
```

```
<!-- child1.vue -->
<template>
  <div>
 <button @click="parentClick">点击访问父组件</button>
  </div>
</template>
<script>
export default {
  data(){
 return {
msg:"child1"
 }
  },
  methods: {
 // 访问父组件数据
 parentClick(){
this.$parent.funa("xx")
console.log(this.$parent.total);
 }
  }
}
</script>
复制代码
```

```
<!-- child2.vue -->
<template>
  <div>
 child2
  </div>
</template>
<script>
export default {
  data(){
 return {
  msg: 'child2'
 }
  }
}
</script>
复制代码
```

**4\. attrs+attrs + listeners多级组件通信**

> `$attrs` 包含了从父组件传过来的所有`props`属性

```
// 父组件Parent.vue: 
<Child :name="name" :age="age"/>

// 子组件Child.vue: 
<GrandChild v-bind="$attrs" />

// 孙子组件GrandChild
<p>姓名: {{$attrs.name}}</p>
<p>年龄: {{$attrs.age}}</p>
复制代码
```

> `$listeners`包含了父组件监听的所有事件

```
// 父组件Parent.vue: 
<Child :name="name" :age="age" @changeNameFn="changeName"/>

// 子组件Child.vue: 
<button @click="$listeners.changeNameFn"></button>
复制代码
```

**5\. ref 父子组件通信**

```
// 父组件Parent.vue: 
<Child ref="childComp"/>
<button @click="changeName"></button>
changeName(){
 console.log(this.$refs.childComp.age);
 this.$refs.childComp.changeAge()
}

// 子组件Child.vue: 
data(){
 return{
  age:20
 }
},
methods(){
 changeAge(){
  this.age=15
  }
}
复制代码
```

**6\. 非父子, 兄弟组件之间通信**

> `vue2`中废弃了`broadcast`广播和分发事件的方法。父子组件中可以用`props`和`$emit()`。如何实现非父子组件间的通信，可以通过实例一个`vue`实例`Bus`作为媒介，要相互通信的兄弟组件之中，都引入`Bus`，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。`Bus.js`可以是这样:

```
// Bus.js

// 创建一个中央时间总线类  
class Bus {  
  constructor() {  
 this.callbacks = {};// 存放事件的名字  
  }  
  $on(name, fn) {  
 this.callbacks[name] = this.callbacks[name] || [];  
 this.callbacks[name].push(fn);  
  }  
  $emit(name, args) {  
 if (this.callbacks[name]) {  
this.callbacks[name].forEach((cb) => cb(args));  
 }  
  }  
}  

// main.js  
Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上  
// 另一种方式  
Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能  
复制代码
```

```
<template>
 <button @click="toBus">子组件传给兄弟组件</button>
</template>

<script>
export default{
 methods: {
 toBus () {
this.$bus.$emit('foo', '来自兄弟组件')
 }
  }
}
</script>
复制代码
```

另一个组件也在钩子函数中监听`on`事件

```
export default {
  data() {
 return {
message: ''
 }
  },
  mounted() {
 this.$bus.$on('foo', (msg) => {
this.message = msg
 })
  }
}
复制代码
```

**7\. $root 访问根组件中的属性或方法**

- 作用: 访问根组件中的属性或方法
- 注意: 是根组件，不是父组件。`$root`只对根组件有用

```
var vm = new Vue({
  el: "#app",
  data() {
 return {
rootInfo:"我是根元素的属性"
 }
  },
  methods: {
 alerts() {
alert(111)
 }
  },
  components: {
 com1: {
data() {
  return {
 info: "组件1"
  }
},
template: "<p>{{ info }} <com2></com2></p>",
components: {
  com2: {
 template: "<p>我是组件1的子组件</p>",
 created() {
this.$root.alerts()// 根组件方法
console.log(this.$root.rootInfo)// 我是根元素的属性
 }
  }
}
 }
  }
});
复制代码
```

**8\. vuex**

- 适用场景: 复杂关系的组件数据传递
- Vuex作用相当于一个用来存储共享变量的容器

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a6918a6a2004091b246e14e55689dcc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- `state`用来存放共享变量的地方
- `getter`，可以增加一个`getter`派生状态，(相当于`store`中的计算属性），用来获得共享变量的值
- `mutations`用来存放修改`state`的方法。
- `actions`也是用来存放修改state的方法，不过`action`是在`mutations`的基础上进行。常用来做一些异步操作

**小结**

- 父子关系的组件数据传递选择 `props` 与 `$emit`进行传递，也可选择`ref`
- 兄弟关系的组件数据传递可选择`$bus`，其次可以选择`$parent`进行传递
- 祖先与后代组件数据传递可选择`attrs`与`listeners`或者 `Provide`与 `Inject`
- 复杂关系的组件数据传递可以通过`vuex`存放共享的变量

#### 双向绑定的原理是什么

我们都知道 `Vue` 是数据双向绑定的框架，双向绑定由三个重要部分构成

- 数据层（Model）: 应用的数据及业务逻辑
- 视图层（View）: 应用的展示效果，各类UI组件
- 业务逻辑层（ViewModel）: 框架封装的核心，它负责将数据与视图关联起来

而上面的这个分层的架构方案，可以用一个专业术语进行称呼: `MVVM`这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理

**理解ViewModel**

它的主要职责就是:

- 数据变化后更新视图
- 视图变化后更新数据

当然，它还有两个主要部分组成

- 监听器（`Observer`）: 对所有数据的属性进行监听
- 解析器（`Compiler`）: 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数

#### 写过自定义指令吗？原理是什么

回答范例

1. `Vue`有一组默认指令，比如`v-model`或`v-for`，同时`Vue`也允许用户注册自定义指令来扩展Vue能力

2. 自定义指令主要完成一些可复用低层级`DOM`操作

3. 使用自定义指令分为定义、注册和使用三步:

- 定义自定义指令有两种方式: 对象和函数形式，前者类似组件定义，有各种生命周期；后者只会在`mounte`d和`updated`时执行

- 注册自定义指令类似组件，可以使用`app.directive()`全局注册，使用`{directives:{xxx}}`局部注册

- 使用时在注册名称前加上`v-`即可，比如`v-focus`

4. 我在项目中常用到一些自定义指令，例如:

- 复制粘贴 `v-copy`

- 长按 `v-longpress`

- 防抖 `v-debounce`

- 图片懒加载 `v-lazy`

- 按钮权限 `v-premission`

- 页面水印 `v-waterMarker`

- 拖拽指令 `v-draggable`

5. `vue3`中指令定义发生了比较大的变化，主要是钩子的名称保持和组件一致，这样开发人员容易记忆，不易犯错。另外在`v3.2`之后，可以在`setup`中以一个小写`v`开头方便的定义自定义指令，更简单了

**基本使用**

> 当Vue中的核心内置指令不能够满足我们的需求时，我们可以定制自定义的指令用来满足开发的需求

我们看到的`v-`开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能，对普通 DOM元素进行底层操作，这时候就会用到自定义指令。除了核心功能默认内置的指令 (`v-model` 和 `v-show`)，`Vue` 也允许注册自定义指令

```
// 指令使用的几种方式: 
//会实例化一个指令，但这个指令没有参数 
`v-xxx`

// -- 将值传到指令中
`v-xxx="value"`  

// -- 将字符串传入到指令中，如`v-html="'<p>内容</p>'"`
`v-xxx="'string'"` 

// -- 传参数（`arg`），如`v-bind:class="className"`
`v-xxx:arg="value"` 

// -- 使用修饰符（`modifier`）
`v-xxx:arg.modifier="value"` 
复制代码
```

注册一个自定义指令有全局注册与局部注册

```
// 全局注册注册主要是用过Vue.directive方法进行注册
// Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
 // 聚焦元素
 el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
  }
})

// 局部注册通过在组件options选项中设置directive属性
directives: {
  focus: {
 // 指令的定义
 inserted: function (el) {
el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
 }
  }
}

// 然后你可以在模板中任何元素上使用新的 v-focus property，如下: 

<input v-focus />
复制代码
```

**钩子函数**

1. `bind`: 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
2. `inserted`: 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
3. `update`: 被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。
4. `componentUpdated`: 被绑定元素所在模板完成一次更新周期时调用。
5. `unbind`: 只调用一次，指令与元素解绑时调用。

所有的钩子函数的参数都有以下:

- `el`: 指令所绑定的元素，可以用来直接操作 DOM
- `binding`: 一个对象，包含以下 `property`:
  - `name`: 指令名，不包括 `v-` 前缀。
  - `value`: 指令的绑定值，例如: `v-my-directive="1 + 1"` 中，绑定值为 `2`。
  - `oldValue`: 指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。
  - `expression`: 字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
  - `arg`: 传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。
  - `modifiers`: 一个包含修饰符的对象。例如: `v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`
  - `vnode`: `Vue` 编译生成的虚拟节点
  - `oldVnode`: 上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用

除了 `el` 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 `dataset` 来进行

```
<div v-demo="{ color: 'white', text: 'hello!' }"></div>
<script>
 Vue.directive('demo', function (el, binding) {
 console.log(binding.value.color) // "white"
 console.log(binding.value.text)  // "hello!"
 })
</script>
复制代码
```

**应用场景**

使用自定义组件组件可以满足我们日常一些场景，这里给出几个自定义组件的案例:

1. 防抖

```
// 1.设置v-throttle自定义指令
Vue.directive('throttle', {
  bind: (el, binding) => {
 let throttleTime = binding.value; // 防抖时间
 if (!throttleTime) { // 用户若不设置防抖时间，则默认2s
throttleTime = 2000;
 }
 let cbFun;
 el.addEventListener('click', event => {
if (!cbFun) { // 第一次执行
  cbFun = setTimeout(() => {
 cbFun = null;
  }, throttleTime);
} else {
  event && event.stopImmediatePropagation();
}
 }, true);
  },
});
// 2.为button标签设置v-throttle自定义指令
<button @click="sayHello" v-throttle>提交</button>
复制代码
```

2. 图片懒加载

设置一个`v-lazy`自定义组件完成图片懒加载

```js
const LazyLoad = {
  // install方法
  install(Vue,options){
    // 代替图片的loading图
    let defaultSrc = options.default;
    Vue.directive('lazy',{
      bind(el,binding){
        LazyLoad.init(el,binding.value,defaultSrc);
      },
      inserted(el){
        // 兼容处理
        if('InterpObserver' in window){
          LazyLoad.observe(el);
        }else{
          LazyLoad.listenerScroll(el);
        }

      },
    })
  },
  // 初始化
  init(el,val,def){
    // src 储存真实src
    el.setAttribute('src',val);
    // 设置src为loading图
    el.setAttribute('src',def);
  },
  // 利用InterpObserver监听el
  observe(el){
    let io = new InterpObserver(entries => {
      let realSrc = el.dataset.src;
      if(entries[0].isIntersecting){
        if(realSrc){
          el.src = realSrc;
          el.removeAttribute('src');
        }
      }
    });
    io.observe(el);
  },
  // 监听scroll事件
  listenerScroll(el){
    let handler = LazyLoad.throttle(LazyLoad.load,300);
    LazyLoad.load(el);
    window.addEventListener('scroll',() => {
      handler(el);
    });
  },
  // 加载真实图片
  load(el){
    let windowHeight = document.documentElement.clientHeight
    let elTop = el.getBoundingClientRect().top;
    let elBtm = el.getBoundingClientRect().bottom;
    let realSrc = el.dataset.src;
    if(elTop - windowHeight<0&&elBtm > 0){
      if(realSrc){
        el.src = realSrc;
        el.removeAttribute('src');
      }
    }
  },
  // 节流
  throttle(fn,delay){
    let timer; 
    let prevTime;
    return function(...args){
      let currTime = Date.now();
      let context = this;
      if(!prevTime) prevTime = currTime;
      clearTimeout(timer);

      if(currTime - prevTime > delay){
        prevTime = currTime;
        fn.apply(context,args);
        clearTimeout(timer);
        return;
      }

      timer = setTimeout(function(){
        prevTime = Date.now();
        timer = null;
        fn.apply(context,args);
      },delay);
    }
  }

}
export default LazyLoad;
```

3. 一键 Copy的功能

```js
import { Message } from 'ant-design-vue';

const vCopy = { //
  /*
 bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置
 el: 作用的 dom 对象
 value: 传给指令的值，也就是我们要 copy 的值
  */
  bind(el, { value }) {
    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到
    el.handler = () => {
      if (!el.$value) {
        // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意
        Message.warning('无复制内容');
        return;
      }
      // 动态创建 textarea 标签
      const textarea = document.createElement('textarea');
      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域
      textarea.readOnly = 'readonly';
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      // 将要 copy 的值赋给 textarea 标签的 value 属性
      textarea.value = el.$value;
      // 将 textarea 插入到 body 中
      document.body.appendChild(textarea);
      // 选中值并复制
      textarea.select();
      // textarea.setSelectionRange(0, textarea.value.length);
      const result = document.execCommand('Copy');
      if (result) {
        Message.success('复制成功');
      }
      document.body.removeChild(textarea);
    };
    // 绑定点击事件，就是所谓的一键 copy 啦
    el.addEventListener('click', el.handler);
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value;
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener('click', el.handler);
  },
};

export default vCopy;
```

4. 拖拽

```js
<div ref="a" id="bg" v-drag></div>

directives: {
  drag: {
    bind() {},
      inserted(el) {
        el.onmousedown = (e) => {
          let x = e.clientX - el.offsetLeft;
          let y = e.clientY - el.offsetTop;
          document.onmousemove = (e) => {
            let xx = e.clientX - x + "px";
            let yy = e.clientY - y + "px";
            el.style.left = xx;
            el.style.top = yy;
          };
          el.onmouseup = (e) => {
            document.onmousemove = null;
          };
        };
      },
  },
}
```

**原理**

- 指令本质上是装饰器，是 `vue`对 `HTML` 元素的扩展，给 `HTML` 元素增加自定义功能。`vue` 编译 `DOM` 时，会找到指令对象，执行指令的相关方法。
- 自定义指令有五个生命周期（也叫钩子函数），分别是 `bind`、`inserted`、`update`、`componentUpdated`、`unbind`

**原理**

1. 在生成 `ast` 语法树时，遇到指令会给当前元素添加 `directives` 属性
2. 通过 `genDirectives` 生成指令代码
3. 在 `patch` 前将指令的钩子提取到 `cbs` 中,在 `patch` 过程中调用对应的钩子
4. 当执行指令对应钩子函数时，调用对应指令定义的方法

#### 为什么Vue采用异步渲染

> Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 `nextTick`

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0b0ef1452044172ab7277235932ab8f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

源码相关

> `dep.notify（）` 通知 `watcher`进行更新， `subs[i].update` 依次调用 `watcher` 的 `update` ， `queueWatcher` 将`watcher` 去重放入队列， `nextTick`（ `flushSchedulerQueue` ）在下一`tick`中刷新`watcher`队列（异步）

```
update () { /* istanbul ignore else */ 
 if (this.lazy) { 
  this.dirty = true 
 } 
 else if (this.sync) { 
  this.run() 
 } 
 else { 
  queueWatcher(this); // 当数据发生变化时会将watcher放到一个队列中批量更新 
 }
}

export function queueWatcher (watcher: Watcher) { 
 const id = watcher.id // 会对相同的watcher进行过滤 
 if (has[id] == null) { 
  has[id] = true 
  if (!flushing) { 
queue.push(watcher) 
  } else { 
let i = queue.length - 1 
while (i > index && queue[i].id > watcher.id) { 
 i-- 
}
queue.splice(i + 1, 0, watcher) 
  }
  // queue the flush 
  if (!waiting) { 
waiting = true 
if (process.env.NODE_ENV !== 'production' && !config.async) { 
 flushSchedulerQueue() 
 return 
}
nextTick(flushSchedulerQueue) // 调用nextTick方法 批量的进行更新 
  } 
 } 
}
复制代码
```

#### vue-router 路由钩子函数是什么 执行顺序是什么

> 路由钩子的执行流程, 钩子函数种类有:`全局守卫`、`路由守卫`、`组件守卫`

1. 导航被触发。
2. 在失活的组件里调用 `beforeRouteLeave` 守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (`2.2+`)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫 (`2.5+`)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 `DOM` 更新。
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入

#### 子组件可以直接改变父组件的数据吗？

子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。

Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

**只能通过**`$emit`**派发一个自定义事件，父组件接收到后，由父组件修改。**

-

#### Composition API 与 Options API 有什么不同

**分析**

`Vue3`最重要更新之一就是`Composition API`，它具有一些列优点，其中不少是针对`Options API`暴露的一些问题量身打造。是`Vue3`推荐的写法，因此掌握好`Composition API`应用对掌握好`Vue3`至关重要

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5142ecfe8de74b40912ffc39ff0ec6aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

[What is Composition API?(opens new window)](https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fextras%2Fcomposition-api-faq.html%23what-is-composition-api "https://vuejs.org/guide/extras/composition-api-faq.html#what-is-composition-api")

- `Composition API`出现就是为了解决Options API导致相同功能代码分散的现象

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9831fceec1d34cfba75f1623f55c720b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b858b0c91d1f44feae54cd5d644d0e09~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**体验**

`Composition API`能更好的组织代码，下面用`composition api`可以提取为`useCount()`，用于组合、复用

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd5f2ab4a50940e887621bec8709768b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**compositon api提供了以下几个函数:**

- `setup`
- `ref`
- `reactive`
- `watchEffect`
- `watch`
- `computed`
- `toRefs`
- 生命周期的`hooks`

**回答范例**

1. `Composition API`是一组`API`，包括: `Reactivity API`、`生命周期钩子`、`依赖注入`，使用户可以通过导入函数方式编写`vue`组件。而`Options API`则通过声明组件选项的对象形式编写组件
2. `Composition API`最主要作用是能够简洁、高效复用逻辑。解决了过去`Options API`中`mixins`的各种缺点；另外`Composition API`具有更加敏捷的代码组织能力，很多用户喜欢`Options API`，认为所有东西都有固定位置的选项放置代码，但是单个组件增长过大之后这反而成为限制，一个逻辑关注点分散在组件各处，形成代码碎片，维护时需要反复横跳，`Composition API`则可以将它们有效组织在一起。最后`Composition API`拥有更好的类型推断，对ts支持更友好，`Options API`在设计之初并未考虑类型推断因素，虽然官方为此做了很多复杂的类型体操，确保用户可以在使用`Options API`时获得类型推断，然而还是没办法用在`mixins`和`provide/inject`上
3. `Vue3`首推`Composition API`，但是这会让我们在代码组织上多花点心思，因此在选择上，如果我们项目属于中低复杂度的场景，`Options API`仍是一个好选择。对于那些大型，高扩展，强维护的项目上，`Composition API`会获得更大收益

**可能的追问**

1. `Composition API`能否和`Options API`一起使用？

可以在同一个组件中使用两个`script`标签，一个使用vue3，一个使用vue2写法，一起使用没有问题

```
<!-- vue3 -->
<script setup>
  // vue3写法
</script>

<!-- 降级vue2 -->
<script>
  export default {
 data() {},
 methods: {}
  }
</script>
复制代码
```

#### vue-router中如何保护路由

**分析**

路由保护在应用开发过程中非常重要，几乎每个应用都要做各种路由权限管理，因此相当考察使用者基本功。

**体验**

全局守卫:

```
const router = createRouter({ ... })

router.beforeEach((to, from) => {
  // ...
  // 返回 false 以取消导航
  return false
})
复制代码
```

路由独享守卫:

```
const routes = [
  {
 path: '/users/:id',
 component: UserDetails,
 beforeEnter: (to, from) => {
// reject the navigation
return false
 },
  },
]
复制代码
```

组件内的守卫:

```
const UserDetails = {
  template: `...`,
  beforeRouteEnter(to, from) {
 // 在渲染该组件的对应路由被验证前调用
  },
  beforeRouteUpdate(to, from) {
 // 在当前路由改变，但是该组件被复用时调用
  },
  beforeRouteLeave(to, from) {
 // 在导航离开渲染该组件的对应路由时调用
  },
}
复制代码
```

**回答**

- `vue-router`中保护路由的方法叫做路由守卫，主要用来通过跳转或取消的方式守卫导航。
- 路由守卫有三个级别: `全局`、`路由独享`、`组件级`。影响范围由大到小，例如全局的`router.beforeEach()`，可以注册一个全局前置守卫，每次路由导航都会经过这个守卫，因此在其内部可以加入控制逻辑决定用户是否可以导航到目标路由；在路由注册的时候可以加入单路由独享的守卫，例如`beforeEnter`，守卫只在进入路由时触发，因此只会影响这个路由，控制更精确；我们还可以为路由组件添加守卫配置，例如`beforeRouteEnter`，会在渲染该组件的对应路由被验证前调用，控制的范围更精确了。
- 用户的任何导航行为都会走`navigate`方法，内部有个`guards`队列按顺序执行用户注册的守卫钩子函数，如果没有通过验证逻辑则会取消原有的导航。

**原理**

`runGuardQueue(guards)`链式的执行用户在各级别注册的守卫钩子函数，通过则继续下一个级别的守卫，不通过进入`catch`流程取消原本导航

```
// 源码
runGuardQueue(guards)
  .then(() => {
 // check global guards beforeEach
 guards = []
 for (const guard of beforeGuards.list()) {
guards.push(guardToPromiseFn(guard, to, from))
 }
 guards.push(canceledNavigationCheck)

 return runGuardQueue(guards)
  })
  .then(() => {
 // check in components beforeRouteUpdate
 guards = extractComponentsGuards(
updatingRecords,
'beforeRouteUpdate',
to,
from
 )

 for (const record of updatingRecords) {
record.updateGuards.forEach(guard => {
  guards.push(guardToPromiseFn(guard, to, from))
})
 }
 guards.push(canceledNavigationCheck)

 // run the queue of per route beforeEnter guards
 return runGuardQueue(guards)
  })
  .then(() => {
 // check the route beforeEnter
 guards = []
 for (const record of to.matched) {
// do not trigger beforeEnter on reused views
if (record.beforeEnter && !from.matched.includes(record)) {
  if (isArray(record.beforeEnter)) {
 for (const beforeEnter of record.beforeEnter)
guards.push(guardToPromiseFn(beforeEnter, to, from))
  } else {
 guards.push(guardToPromiseFn(record.beforeEnter, to, from))
  }
}
 }
 guards.push(canceledNavigationCheck)

 // run the queue of per route beforeEnter guards
 return runGuardQueue(guards)
  })
  .then(() => {
 // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>

 // clear existing enterCallbacks, these are added by extractComponentsGuards
 to.matched.forEach(record => (record.enterCallbacks = {}))

 // check in-component beforeRouteEnter
 guards = extractComponentsGuards(
enteringRecords,
'beforeRouteEnter',
to,
from
 )
 guards.push(canceledNavigationCheck)

 // run the queue of per route beforeEnter guards
 return runGuardQueue(guards)
  })
  .then(() => {
 // check global guards beforeResolve
 guards = []
 for (const guard of beforeResolveGuards.list()) {
guards.push(guardToPromiseFn(guard, to, from))
 }
 guards.push(canceledNavigationCheck)

 return runGuardQueue(guards)
  })
  // catch any navigation canceled
  .catch(err =>
 isNavigationFailure(err, ErrorTypes.NAVIGATION_CANCELLED)
? err
: Promise.reject(err)
  )
复制代码
```

### 全局配置

- silent: 取消 Vue 所有的日志与警告。
- optionMergeStrategies: 自定义合并策略的选项。合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。
- devtools: 配置是否允许 `vue-devtools` 检查代码。开发版本默认为 `true`，生产版本默认为 `false`。生产版本设为 `true` 可以启用检查。
- errorHandler: 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。
- warnHandler: 为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。
- ignoredElements:
- keyCodes: 给 `v-on` 自定义键位别名。
- performance: 设置为 `true` 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 `performance.mark` API 的浏览器上。
- productionTip: 设置为 `false` 以阻止 vue 在启动时生成生产提示。

### 全局 API

- Vue.extend: 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。
- Vue.nextTick: 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
- Vue.set: 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 `this.myObject.newProperty = 'hi'`)
- Vue.delete: 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。
- Vue.directive: 注册或获取全局指令。
- Vue.filter: 注册或获取全局过滤器。
- Vue.component: 注册或获取全局组件。注册还会自动使用给定的 `id` 设置组件的名称
- Vue.use: 安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。
- Vue.mixin: 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。**不推荐在应用代码中使用**。
- Vue.compile: 将一个模板字符串编译成 render 函数。**只在完整版时可用**。
- Vue.observable: 让一个对象可响应。Vue 内部会用它来处理 `data` 函数返回的对象。
- Vue.version: 提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。

#### `Vue.extend` 和 `Vue.component` 的区别是什么？

*Vue.extend* 用于创建一个基于 *Vue* 构造函数的“子类”，其参数应为一个包含组件选项的对象。

*Vue.component* 用来注册全局组件。

#### nextTick 的作用是什么？实现原理是什么？

**作用**

vue*更新*DOM*是异步更新的，数据变化，*DOM*的更新不会马上完成，*nextTick*的回调是在下次*DOM* 更新循环结束之后执行的延迟回调。

**实现原理**

nextTick* 主要使用了宏任务和微任务。根据执行环境分别尝试采用

- *Promise*: 可以将函数延迟到当前函数调用栈最末端
- *MutationObserver* : 是 *H5* 新加的一个功能，其功能是监听 *DOM* 节点的变动，在所有 *DOM* 变动完成后，执行回调函数
- *setImmediate*: 用于中断长时间运行的操作，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数
- 如果以上都不行则采用 *setTimeout* 把函数延迟到 DOM 更新之后再使用

原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务。

#### Vue.extend 作用和原理

> 官方解释: `Vue.extend` 使用基础 `Vue` 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

其实就是一个子类构造器 是 `Vue` 组件的核心 `api` 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 `mergeOptions` 把传入组件的 `options` 和父类的 `options` 进行了合并

- `extend`是构造一个组件的语法器。然后这个组件你可以作用到`Vue.component`这个全局注册方法里还可以在任意`vue`模板里使用组件。 也可以作用到`vue`实例或者某个组件中的`components`属性中并在内部使用`apple`组件。
- `Vue.component`你可以创建 ，也可以取组件。

相关代码如下

```js
export default function initExtend(Vue) {
  let cid = 0; //组件的唯一标识
  // 创建子类继承Vue父类 便于属性扩展
  Vue.extend = function (extendOptions) {
 // 创建子类的构造函数 并且调用初始化方法
 const Sub = function VueComponent(options) {
this._init(options); //调用Vue初始化方法
 };
 Sub.cid = cid++;
 Sub.prototype = Object.create(this.prototype); // 子类原型指向父类
 Sub.prototype.constructor = Sub; //constructor指向自己
 Sub.options = mergeOptions(this.options, extendOptions); //合并自己的options和父类的options
 return Sub;
  };
}
```

### 选项 / 数据

- data:
- props: props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。
- propsData: 创建实例时传递 props。主要作用是方便测试。
- computed: 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。
- methods: methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。
- watch: 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个 property。



#### 分别简述computed和watch的使用场景

**computed**:  

- 当一个属性受多个属性影响的时候就需要用到computed 
- 最典型的栗子:  购物车商品结算的时候  

**watch**:  

- 当一条数据影响多条数据的时候就需要用watch  
- 栗子: 搜索数据  

#### Vue 组件的 data 为什么必须是函数

组件中的 *data* 写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的 *data*，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 *data*，就会造成一个变了全都会变的结果。

#### 说一下 Vue 的 computed 的实现原理

当组件实例触发生命周期函数 *beforeCreate* 后，它会做一系列事情，其中就包括对 *computed* 的处理。

它会遍历 *computed* 配置中的所有属性，为每一个属性创建一个 *Watcher* 对象，并传入一个函数，该函数的本质其实就是 *computed* 配置中的 *getter*，这样一来，*getter* 运行过程中就会收集依赖

但是和渲染函数不同，为计算属性创建的 *Watcher* 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 *Watcher* 的时候，它使用了 *lazy* 配置，*lazy* 配置可以让 *Watcher* 不会立即执行。

收到 *lazy* 的影响，*Watcher* 内部会保存两个关键属性来实现缓存，一个是 *value*，一个是 *dirty*

*value* 属性用于保存 *Watcher* 运行的结果，受 *lazy* 的影响，该值在最开始是 *undefined*

*dirty* 属性用于指示当前的 *value* 是否已经过时了，即是否为脏值，受 *lazy* 的影响，该值在最开始是 *true*

Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中

当读取计算属性时，*vue* 检查其对应的 *Watcher* 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 *Watcher* 的 *value* 中，然后设置 *dirty* 为 *false*，然后返回。

如果 *dirty* 为 *false*，则直接返回 *watcher* 的 *value*

巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 *Watcher*，还会收集到组件的 *Watcher*

当计算属性的依赖变化时，会先触发计算属性的 *Watcher* 执行，此时，它只需设置 *dirty* 为 *true* 即可，不做任何处理。

由于依赖同时会收集到组件的 *Watcher*，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 *getter* 进行运算

而对于计算属性的 *setter*，则极其简单，当设置计算属性时，直接运行 *setter* 即可。

#### `Watch`中的`deep:true`是如何实现的

当用户指定了 `watch` 中的deep属性为 `true` 时，如果当前监控的值是数组类型。会对对象中的每一项进行求值，此时会将当前 `watcher`存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新

**源码相关**

```js
get () { 
  pushTarget(this) // 先将当前依赖放到 Dep.target上 
  let value 
  const vm = this.vm 
  try { 
    value = this.getter.call(vm, vm) 
  } catch (e) { 
    if (this.user) { 
      handleError(e, vm, `getter for watcher "${this.expression}"`) 
    } else { 
      throw e 
    } 
  } finally { 
    if (this.deep) { // 如果需要深度监控 
      traverse(value) // 会对对象中的每一项取值,取值时会执行对应的get方法 
    }
    popTarget() 
  }
```

#### 说一下 `watch` 与 `computed` 的区别是什么？以及他们的使用场景分别是什么？

**区别:**

1. 都是观察数据变化的（相同）
2. 计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化；
3. computed 有缓存，它依赖的值变了才会重新计算，watch 没有；
4. watch 支持异步，computed 不支持；
5. watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）
6. watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；
7. computed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）

**watch 的 参数:**

- deep: 深度监听
- immediate : 组件加载立即触发回调函数执行

**computed 缓存原理:**

conputed本质是一个惰性的观察者；当计算数据存在于 data 或者 props里时会被警告；

vue 初次运行会对 computed 属性做初始化处理（initComputed），初始化的时候会对每一个 computed 属性用  watcher 包装起来 ，这里面会生成一个 dirty 属性值为 true；然后执行 defineComputed 函数来计算，计算之后会将  dirty 值变为 false，这里会根据 dirty 值来判断是否需要重新计算；如果属性依赖的数据发生变化，computed 的  watcher 会把 dirty 变为 true，这样就会重新计算 computed 属性的值。

### 选项 / DOM

- el: 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。
- template: 一个字符串模板作为 Vue 实例的标识使用。模板将会**替换**挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。
- render: 字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 `createElement` 方法作为第一个参数用来创建 `VNode`。
- renderError: **只在开发者环境下工作。**当 `render` 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 `renderError`。这个功能配合 hot-reload 非常实用。

### 选项 / 生命周期钩子

![](https://v2.cn.vuejs.org/images/lifecycle.png)

- beforeCreate: 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。
- created: 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕: 数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 `$el` property 目前尚不可用。
- beforeMount: 在挂载开始之前被调用: 相关的 render 函数首次被调用。**该钩子在服务器端渲染期间不被调用。**
- mounted: 实例被挂载后调用，这时 el 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内。注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted 内部使用 `vm.$nextTick`。**该钩子在服务器端渲染期间不被调用。**
- beforeUpdate: 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。**该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。**
- updated: 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 vm.$nextTick。**该钩子在服务器端渲染期间不被调用。**
- activated: 被 `keep-alive` 缓存的组件激活时调用。**该钩子在服务器端渲染期间不被调用。**
- deactivated: 被 keep-alive 缓存的组件失活时调用。**该钩子在服务器端渲染期间不被调用。**
- beforeDestroy: 实例销毁之前调用。在这一步，实例仍然完全可用。**该钩子在服务器端渲染期间不被调用。**
- destoryed: 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。**该钩子在服务器端渲染期间不被调用。**
- errorCaptured: 在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数: 错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。



#### 解释一下对 `Vue` 生命周期的理解

- 什么是 *vue* 生命周期
- *vue* 生命周期的作用是什么
- *vue* 生命周期有几个阶段
- 第一次页面加载会触发哪几个钩子
- *DOM* 渲染在哪个周期就已经完成
- 多组件（父子组件）中生命周期的调用顺序说一下



#### 什么是 `vue` 生命周期

对于 *vue* 来讲，生命周期就是一个 *vue* 实例从创建到销毁的过程。

#### `vue` 生命周期的作用是什么

在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。

其实和回调是一个概念，当系统执行到某处时，检查是否有 *hook*(钩子)，有的话就会执行回调。

通俗的说，*hook* 就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写。

#### `vue` 生命周期有几个阶段

它可以总共分为 *8* 个阶段: 创建前/后, 载入前/后,更新前/后,销毁前/销毁后。

- *beforeCreate*: 是 *new Vue( )* 之后触发的第一个钩子，在当前阶段 *data、methods、computed* 以及 *watch* 上的数据和方法都不能被访问。
- *created*: 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 *updated* 函数。可以做一些初始数据的获取，在当前阶段无法与 *DOM* 进行交互，如果非要想，可以通过 *vm.$nextTick* 来访问 *DOM* 。
- *beforeMount*: 发生在挂载之前，在这之前 *template* 模板已导入渲染函数编译。而当前阶段虚拟 *DOM* 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 *updated*。
- *mounted*: 在挂载完成后发生，在当前阶段，真实的 *DOM* 挂载完毕，数据完成双向绑定，可以访问到 *DOM* 节点，使用 *$refs* 属性对 *DOM* 进行操作。
- *beforeUpdate*: 发生在更新之前，也就是响应式数据发生更新，虚拟 *DOM* 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。
- *updated*: 发生在更新完成之后，当前阶段组件 *DOM* 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
- *beforeDestroy*: 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
- *destroyed*: 发生在实例销毁之后，这个时候只剩下了 *DOM* 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

#### 第一次页面加载会触发哪几个钩子

会触发 *4* 个钩子，分别是: *beforeCreate、created、beforeMount、mounted*

#### `DOM` 渲染在哪个周期就已经完成

*DOM* 渲染是在 *mounted* 阶段完成，此阶段真实的 *DOM* 挂载完毕，数据完成双向绑定，可以访问到 *DOM* 节点。

#### 多组件（父子组件）中生命周期的调用顺序说一下

组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。

- 加载渲染过程: 父*beforeCreate*->父*created*->父*beforeMount*->子*beforeCreate*->子*created*->子*beforeMount*- >子*mounted*->父*mounted*
- 子组件更新过程: 父*beforeUpdate*->子*beforeUpdate*->子*updated*->父*updated*
- 父组件更新过程: 父 *beforeUpdate* -> 父 *updated*
- 销毁过程: 父*beforeDestroy*->子*beforeDestroy*->子*destroyed*->父*destroyed*

#### 接口请求一般放在哪个生命周期中？为什么要这样做？

接口请求可以放在钩子函数 *created、beforeMount、mounted* 中进行调用，因为在这三个钩子函数中，*data* 已经创建，可以将服务端端返回的数据进行赋值。

但是推荐在 *created* 钩子函数中调用异步请求，因为在 *created* 钩子函数中调用异步请求有以下优点:

- 能更快获取到服务端数据，减少页面 *loading* 时间
- *SSR* 不支持 *beforeMount 、mounted* 钩子函数，所以放在 *created* 中有助于代码的一致性
- *created* 是在模板渲染成 *html* 前调用，即通常初始化某些属性值，然后再渲染成视图。如果在 *mounted* 钩子函数中请求数据可能导致页面闪屏问题

#### 什么是 vue 生命周期？有什么作用？

每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps: 生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。  

#### 第一次页面加载会触发哪几个钩子？

beforeCreate， created， beforeMount， mounted  

#### 父子组件生命周期的执行顺序？

**加载渲染阶段**

在加载渲染阶段，一定得等**子组件**挂载完毕后，**父组件**才能挂载完毕，所以父组件的 mounted 在最后。  

`beforeCreate（父组件）` → `created（父组件）` → `beforeMount（父组件）` → `beforeCreate（子组件）` → `created（子组件）` → `beforeMount（子组件）` → `Mounted（子组件）` → `Mounted（父组件）`

**更新阶段**

当父子组件有**数据传递**时，才有这个更新阶段执行顺序的比较。  

`beforeUpdate（父组件）` → `beforeUpdate（子组件）` → `updated（子组件）` → `updated（父组件）`

**销毁阶段**

`beforeDestroy（父组件）` → `beforeDestroy（子组件）` → `destroyed（子组件）` → `destroyed（父组件）`

**总结**

不过要**注意**一点的是: 如果`子组件`是`异步组件`的话它们的执行顺序会发生改变，会先执行完`父组件`的生命周期然后再执行`子组件`的生命周期。

#### 简述每个周期具体适合哪些场景

beforeCreate: 在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法  

create: data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作  

beforeMount: 执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的  

mounted: 执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行  

beforeUpdate:  当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步  

updated: 页面显示的数据和data中的数据已经保持同步了，都是最新的  

beforeDestory: Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁  

destroyed:  这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。  

#### created和mounted的区别

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。  

mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。  

#### vue获取数据在哪个周期函数

一般 created/beforeMount/mounted 皆可.  

比如如果你要操作 DOM , 那肯定 mounted 时候才能操作.  

#### 请详细说下你对vue生命周期的理解？

总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。  

创建前/后:  在beforeCreated阶段，vue实例的挂载元素$el和**数据对象**data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。  

载入前/后: 在beforeMount阶段，vue实例的`$el`和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。  

更新前/后: 当data变化时，会触发beforeUpdate和updated方法。  

销毁前/后: 在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。  

#### 什么是 vue 生命周期？有什么作用？  

每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps: 生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。  

#### 第一次页面加载会触发哪几个钩子？  

beforeCreate， created， beforeMount， mounted  

#### 简述每个周期具体适合哪些场景

beforeCreate: 在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法  
create: data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作  
beforeMount: 执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的  
mounted: 执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行  
beforeUpdate:  当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步  
updated: 页面显示的数据和data中的数据已经保持同步了，都是最新的  
beforeDestory: Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁  
destroyed:  这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。  

#### created和mounted的区别

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。  
mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。  

#### vue获取数据在哪个周期函数

一般 created/beforeMount/mounted 皆可.  
比如如果你要操作 DOM , 那肯定 mounted 时候才能操作.  

#### 请详细说下你对vue生命周期的理解？  

总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。  
创建前/后:  在beforeCreated阶段，vue实例的挂载元素$el和**数据对象**data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。  
载入前/后: 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。  
更新前/后: 当data变化时，会触发beforeUpdate和updated方法。  
销毁前/后: 在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。  
vue路由面试题  
**1.mvvm 框架是什么？  
vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。  
**2.vue-router 是什么?它有哪些组件**  
vue用来写路由一个插件。router-link、router-view  
**3.active-class 是哪个组件的属性？  
vue-router模块的router-link组件。children数组来定义子路由  
**4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值？  
在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id。  
**5.vue-router 有哪几种导航钩子?  
三种，  
第一种: 是全局导航钩子: router.beforeEach(to,from,next)，作用: 跳转前进行判断拦截。  
第二种: 组件内的钩子  
第三种: 单独路由独享组件  
**6.$route 和 $router 的区别**  
$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$router.push方法。返回上一个历史history用$router.to(-1)  
$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。  

### 选项 / 资源

- directives: 包含 Vue 实例可用指令的哈希表。
- filters: 包含 Vue 实例可用过滤器的哈希表。
- components: 包含 Vue 实例可用组件的哈希表。

### 选项 / 组合

- parent: 指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。
- mixins: `mixins` 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 `Vue.extend()` 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。
- extends: 允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件。这和 `mixins` 类似。
- provide / inject: 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。

### 选项 / 其它

- name: 允许组件模板递归地调用自身。注意，组件在全局用 `Vue.component()` 注册时，全局 ID 自动作为组件的 name。指定 `name` 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 [vue-devtools](https://github.com/vuejs/vue-devtools)，未命名组件将显示成 `<AnonymousComponent>`，这很没有语义。通过提供 `name` 选项，可以获得更有语义信息的组件树。
- delimiters: 改变纯文本插入分隔符。
- functional: 使组件无状态 (没有 `data`) 和无实例 (没有 `this` 上下文)。他们用一个简单的 `render` 函数返回虚拟节点使它们渲染的代价更小。
- model: 允许一个自定义组件在使用 `v-model` 时定制 prop 和 event。默认情况下，一个组件上的 `v-model` 会把 `value` 用作 prop 且把 `input` 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 `value` prop 来达到不同的目的。使用 `model` 选项可以回避这些情况产生的冲突。
- inheritAttrs: 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的  HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 `inheritAttrs` 到 `false`，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property `$attrs` 可以让这些 attribute 生效，且可以通过 `v-bind` 显性的绑定到非根元素上。
- comments: 当设为 `true` 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。

### 实例 property

- vm.$data: Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。
- vm.$props: 当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。
- vm.$el: Vue 实例使用的根 DOM 元素。
- vm.$options: 用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处
- vm.$parent: 父实例，如果当前实例有的话。
- vm.$root: 当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。
- vm.$children: 当前实例的直接子组件。**需要注意 `$children` 并不保证顺序，也不是响应式的。**如果你发现自己正在尝试使用 `$children` 来进行数据绑定，考虑使用一个数组配合 `v-for` 来生成子组件，并且使用 Array 作为真正的来源。
- vm.$slots: 用来访问被插槽分发的内容。每个具名插槽有其相应的 property (例如：`v-slot:foo` 中的内容将会在 `vm.$slots.foo` 中被找到)。default property 包括了所有没有被包含在具名插槽中的节点，或 v-slot:default 的内容。
- vm.$scopedSlots: 用来访问作用域插槽。对于包括 `默认 slot` 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。`vm.$scopedSlots` 在使用渲染函数开发一个组件时特别有用。
- vm.$refs: 一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例。
- vm.$isServer: 当前 Vue 实例是否运行于服务器。
- vm.$attrs: 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (`class` 和 `style` 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (`class` 和 `style` 除外)，并且可以通过 `v-bind="$attrs"` 传入内部组件——在创建高级别的组件时非常有用。
- vm.$listeners: 包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件——在创建更高层次的组件时非常有用。

### 实例方法 / 数据

- vm.$watch: 观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代。
- vm.$set: 这是全局 `Vue.set` 的**别名**。
- vm.$delete: 这是全局 `Vue.delete` 的**别名**。

### 实例方法 / 事件

- `vm.$on(event, callback)`: 监听当前实例上的自定义事件。事件可以由 `vm.$emit` 触发。回调函数会接收所有传入事件触发函数的额外参数。
- `vm.$once(event, callback)`: 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。
- `vm.$off([event, callback])`: 移除自定义事件监听器。
  - 如果没有提供参数，则移除所有的事件监听器；
  - 如果只提供了事件，则移除该事件所有的监听器；
  - 如果同时提供了事件与回调，则只移除这个回调的监听器。
- `vm.$emit(eventName, […args])`: 触发当前实例上的事件。附加参数都会传给监听器回调。

### 实例方法 / 生命周期

- `vm.$mount`:
- `vm.$forceUpdate`: 迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。
- `vm.$nextTick`: 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 `Vue.nextTick` 一样，不同的是回调的 `this` 自动绑定到调用它的实例上。
- `vm.$destroy`: 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。

#### `$nextTick`的使用

当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，  

你需要使用`$nextTick`这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功。  

### 指令

- `v-text`: 更新元素的 `textContent`。如果要更新部分的 `textContent`，需要使用 `{{ Mustache }}` 插值。
- `v-html`: 更新元素的 `innerHTML`。**注意: 内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译**。如果试图使用 `v-html` 组合模板，可以重新考虑是否通过使用组件来替代。
- `v-show`: 根据表达式之真假值，切换元素的 `display` CSS property。当条件变化时该指令触发过渡效果。
- `v-if`: 根据表达式的值的 `truthiness` 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 `<template>`，将提出它的内容作为条件块。当条件变化时该指令触发过渡效果。
- `v-else`: 为 `v-if` 或者 `v-else-if` 添加“else 块”。
- `v-else-if`: 表示 `v-if` 的“else if 块”。可以链式调用。
- `v-for`: 基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 `alias in expression`，为当前遍历的元素提供别名：
- `v-on`: 绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。
- `v-bind`: 动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。
- `v-model`: 在表单控件或者组件上创建双向绑定。
- `v-slot`: 提供具名插槽或需要接收 prop 的插槽。
- `v-pre`: 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。
- `v-cloak`: 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。
- `v-once`: 只渲染元素和组件**一次**。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。



#### 说一说自定义指令有哪些生命周期？

自定义指令的生命周期，有 5 个事件钩子，可以设置指令在某一个事件发生时的具体行为:

- bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。
- inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。
- update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。
- componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。
- unbind: 只调用一次， 指令与元素解绑时调用。

钩子函数的参数 (包括 el，binding，vnode，oldVnode)

- el: 指令所绑定的元素，可以用来直接操作 DOM 。
- binding: 一个对象，包含以下属性: name: 指令名、value: 指令的绑定值、oldValue: 指令绑定的前一个值、expression: 绑定值的字符串形式、arg: 传给指令的参数、modifiers: 一个包含修饰符的对象。
- vnode: Vue 编译生成的虚拟节点。
- oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

#### `v-if` 和 `v-for` 的优先级

当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐v-if和v-for同时使用。  

如果v-if和v-for一起用的话，vue中的的会自动提示v-if应该放到外层去。  

#### `v-show` 和 `v-if` 指令的共同点和不同点？

**共同点**

都能控制元素的显示和隐藏；  

**不同点**

实现本质方法不同，v-show本质就是通过控制css中的display设置为none，控制隐藏，只会编译一次；v-if是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能。  

**总结**

如果要频繁切换某节点，使用v-show(切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用v-if（初始渲染开销较小，切换开销比较大）。  

#### 说出几种 vue 当中的指令和它的用法？

v-model双向数据绑定；  

v-for循环；  

v-if v-show 显示与隐藏；  

v-on事件；v-once: 只绑定一次。  

#### 说一下 `v-for` 与 `v-show` 的区别

**共同点:**

都是动态显示 *DOM* 元素

**区别点:**

- 手段
  - *v-if* 是动态的向 *DOM* 树内添加或者删除 *DOM* 元素
  - *v-show* 是通过设置 *DOM* 元素的 *display* 样式属性控制显隐
- 编译过程
  - *v-if* 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件
  - *v-show* 只是简单的基于 *css* 切换
- 编译条件
  - *v-if* 是惰性的，如果初始条件为假，则什么也不做。只有在条件第一次变为真时才开始局部编译
  - *v-show* 是在任何条件下(首次条件是否为真)都被编译，然后被缓存，而且 *DOM* 元素保留
- 性能消耗
  - *v-if* 有更高的切换消耗
  - *v-show* 有更高的初始渲染消耗
- 使用场景
  - *v-if* 适合运营条件不大可能改变
  - *v-show* 适合频繁切换

### 特殊 attributes

- key: `key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识  VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key  时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。
- ref: `ref` 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 `$refs` 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
- is: 用于动态组件且基于 DOM 内模板的限制来工作。

#### key 的作用和工作原理，存在的问题及解决方案

`key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

**作用:**

#### Vue 中的 Key 的作用是什么？

***key` 的作用主要是为了高效的更新虚拟 `DOM`**。另外*vue*中在使用相同标签名元素的过渡切换时，也会使用到*key*属性，其目的也是为了让*vue*可以区分它们，否则*vue* 只会替换其内部属性而不会触发过渡效果。

解析:

其实不只是 *vue*，*react* 中在执行列表渲染时也会要求给每个组件添加上 *key* 这个属性。

要解释 *key* 的作用，不得不先介绍一下虚拟 *DOM* 的 *Diff* 算法了。

我们知道，*vue* 和 *react* 都实现了一套虚拟 *DOM*，使我们可以不直接操作 *DOM* 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 *Diff* 算法。

*vue* 和 *react* 的虚拟 *DOM* 的 *Diff* 算法大致相同，其核心有以下两点:

- 两个相同的组件产生类似的 *DOM* 结构，不同的组件产生不同的 *DOM* 结构。
- 同一层级的一组节点，他们可以通过唯一的 *id* 进行区分。

基于以上这两点，使得虚拟 *DOM* 的 *Diff* 算法的复杂度从 *O(n^3)* 降到了 *O(n)*。

当页面的数据发生变化时，*Diff* 算法只会比较同一层级的节点:

- 如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。
- 如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。

当某一层有很多相同的节点时，也就是列表节点时，*Diff* 算法的更新过程默认情况下也是遵循以上原则。

比如一下这个情况:

![img](https://img-blog.csdnimg.cn/img_convert/656c62fd7caebb743213881e33ee03ed.jpeg)

我们希望可以在 *B* 和 *C* 之间加一个 *F*，*Diff* 算法默认执行起来是这样的:

![img](https://img-blog.csdnimg.cn/img_convert/abbd3f0f2bb99564252725d9c8a157bc.jpeg)

即把 *C* 更新成 *F*，*D* 更新成 *C*，*E* 更新成 *D*，最后再插入 *E*

是不是很没有效率？

所以我们需要使用 *key* 来给每个节点做一个唯一标识，*Diff* 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。

![img](https://img-blog.csdnimg.cn/img_convert/50e2e434486b84a1c9eeb4680710d8dc.jpeg)

-

#### 为什么使用key?

需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。  

作用主要是为了高效的更新虚拟DOM。  

#### ref 的作用是什么？常见的使用场景？

*ref* 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 *$refs* 对象上。其特点是:

- 如果在普通的 *DOM* 元素上使用，引用指向的就是 *DOM* 元素
- 如果用在子组件上，引用就指向组件实例

所以常见的使用场景有:

1. 基本用法，本页面获取 *DOM* 元素
2. 获取子组件中的 *data*
3. 调用子组件中的方法

### 组件



#### 内置的组件

- `component`: 渲染一个“元组件”为动态组件。依 `is` 的值，来决定哪个组件被渲染。
- `transition`: `<transition>` 元素作为**单个**元素/组件的过渡效果。`<transition>` 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。
- `transition-group`: `<transition-group>` 元素作为多个元素/组件的过渡效果。`<transition-group>` 渲染一个真实的 DOM 元素。默认渲染 `<span>`，可以通过 `tag` attribute 配置哪个元素应该被渲染。
- `keep-alive`: `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件: 它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。
- `slot`: `<slot>` 元素作为组件模板之中的内容分发插槽。`<slot>` 元素自身将被替换。

#### `keep-alive`的作用是什么?

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。  

#### 请说下封装 vue 组件的过程？  

1. 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。(os: 思考1小时，码码10分钟，程序猿的准则。)  

   2. 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。  
3. 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。  
4. 封装完毕了，直接调用即可  

#### 谈一谈对Vue组件化的理解

- 组件化开发能大幅提高开发效率、测试性、复用性等
- 常用的组件化技术: 属性、自定义事件、插槽
- 降低更新频率，只重新渲染变化的组件
- 组件的特点: 高内聚、低耦合、单向数据流

#### vue父组件向子组件传递数据？  

通过props  

#### 子组件像父组件传递事件？

$emit方法

#### Vue 中如何进行组件的使用？`Vue` 如何实现全局组件的注册？

要使用组件，首先需要使用 *import* 来引入组件，然后在 *components* 属性中注册组件，之后就可以在模板中使用组件了。

可以使用 *Vue.component* 方法来实现全局组件的注册。





### 虚拟 DOM

### Vue@2

### Vue@3

### 其它

# Vue Router



#### Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？

Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决。  

#### Vue2中注册在router-link上事件无效解决方法

 使用@click.native。原因: router-link会阻止click事件，.native指直接监听一个原生事件。  

#### `router-link` 在IE和Firefox中不起作用（路由不跳转）的问题

方法一: 只用a标签，不适用button标签；

方法二: 使用button标签和Router.navigate方法  

#### 解释 `hash` 模式和 `history` 模式的实现原理

`#` 后面 *hash* 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；通过监听 *hashchange* 事件可以知道 *hash* 发生了哪些变化，然后根据 *hash* 变化来实现更新页面部分内容的操作。

*history* 模式的实现，主要是 *HTML5* 标准发布的两个 *API*，*pushState* 和 *replaceState*，这两个 *API* 可以在改变 *URL*，但是不会发送请求。这样就可以监听 *url* 变化来实现更新页面部分内容的操作。

两种模式的区别:

- 首先是在 *URL* 的展示上，*hash* 模式有“#”，*history* 模式没有
- 刷新页面时，*hash* 模式可以正常加载到 *hash* 值对应的页面，而 *history* 没有处理的话，会返回 *404*，一般需要后端将所有页面都配置重定向到首页路由
- 在兼容性上，*hash* 可以支持低版本浏览器和 *IE*

#### 说一下`router` 与 `route` 的区别

*$route* 对象表示当前的路由信息，包含了当前 *URL* 解析得到的信息。包含当前的路径，参数，*query* 对象等。

- *$route.path*: 字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。
- *$route.params*:  一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。
- *route.query∗: 一个key/value对象，表示URL查询参数。例如对于路径∗/foo?user=1∗，则有∗ route.query`: 一个 key/value 对象，表示 URL 查询参数。例如对于路径`/foo?user=1`，则有`route.query∗: 一个key/value对象，表示URL查询参数。例如对于路径∗/foo?user=1∗，则有∗route.query.user == 1*，如果没有查询参数，则是个空对象。
- *$route.hash*: 当前路由的 hash 值 (不带 #) ，如果没有 *hash* 值，则为空字符串。
- *$route.fullPath*: 完成解析后的 *URL*，包含查询参数和 *hash* 的完整路径。
- *$route.matched*: 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。
- *$route.name*: 当前路径名字
- *$route.meta*: 路由元信息

*$route* 对象出现在多个地方:

- 组件内的 *this.$route* 和 *route watcher* 回调（监测变化处理）
- *router.match(location)* 的返回值
- *scrollBehavior* 方法的参数
- 导航钩子的参数，例如 *router.beforeEach* 导航守卫的钩子函数中，*to* 和 *from* 都是这个路由信息对象。

*$router* 对象是全局路由的实例，是 *router* 构造方法的实例。

*$router* 对象常用的方法有:

- *push*: 向 *history* 栈添加一个新的记录
- *go*: 页面路由跳转前进或者后退
- *replace*: 替换当前的页面，不会向 *history* 栈添加一个新的记录

#### `vueRouter` 有哪几种导航守卫？

- 全局前置/钩子: *beforeEach、beforeR-esolve、afterEach*
- 路由独享的守卫: *beforeEnter*
- 组件内的守卫: *beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave*

#### 解释一下 `vueRouter` 的完整的导航解析流程是什么

一次完整的导航解析流程如下:

1. 导航被触发。
2. 在失活的组件里调用离开守卫。
3. 调用全局的 *beforeEach* 守卫。
4. 在重用的组件里调用 *beforeRouteUpdate* 守卫（*2.2+*）。
5. 在路由配置里调用 *beforeEnter*。
6. 解析异步路由组件。
7. 在被激活的组件里调用 *beforeRouteEnter*。
8. 调用全局的 *beforeResolve* 守卫（*2.5+*）。
9. 导航被确认。
10. 调用全局的 *afterEach* 钩子。
11. 触发 *DOM* 更新。
12. 用创建好的实例调用 *beforeRouteEnter* 守卫中传给 *next* 的回调函数。

#### vue-router的两种模式

hash模式: 即地址栏 URL 中的 # 符号；  
history模式: window.history对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。  

#### vue-router实现路由懒加载（ 动态加载路由 ）

三种方式  
第一种: vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。  
第二种: 路由懒加载(使用import)。  
第三种: webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。  

#### params和query的区别

**用法**

query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。  

**url地址显示**

query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示  

**注意点**

- query刷新不会丢失query里面的数据  
- params刷新会丢失 params里面的数据。  

#### Vue-router 除了 router-link 怎么实现跳转

声明式导航

```
<router-link to="/about">Go to About</router-link>
复制代码
```

编程式导航

```
// literal string path
router.push('/users/1')

// object with path
router.push({ path: '/users/1' })

// named route with params to let the router build the url
router.push({ name: 'user', params: { username: 'test' } })
复制代码
```

**回答范例**

- `vue-router`导航有两种方式: 声明式导航和编程方式导航
- 声明式导航方式使用`router-link`组件，添加`to`属性导航；编程方式导航更加灵活，可传递调用`router.push()`，并传递`path`字符串或者`RouteLocationRaw`对象，指定`path`、`name`、`params`等信息
- 如果页面中简单表示跳转链接，使用`router-link`最快捷，会渲染一个a标签；如果页面是个复杂的内容，比如商品信息，可以添加点击事件，使用编程式导航
- 实际上内部两者调用的导航函数是一样的

#### vue-router 是什么?它有哪些组件

vue用来写路由一个插件。router-link、router-view

#### active-class 是哪个组件的属性？

vue-router模块的router-link组件。children数组来定义子路由

#### 怎么定义 vue-router 的动态路由? 怎么获取传过来的值？

在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id。

#### vue-router 有哪几种导航钩子?

三种，

第一种: 是全局导航钩子: router.beforeEach(to,from,next)，作用: 跳转前进行判断拦截。

第二种: 组件内的钩子

第三种: 单独路由独享组件

#### `$route` 和 `$router` 的区别

`$router`是 VueRouter 的实例，在script标签中想要导航到不同的URL,使用``$router.push`方法。返回上一个历史history用​`$router.to(-1)`  

$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。

#### vue-router的两种模式

hash模式: 即地址栏 URL 中的 # 符号；

history模式: window.history对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。

#### vue-router是如何实现路由懒加载（ 动态加载路由 ）

三种方式

第一种: vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。

第二种: 路由懒加载(使用import)。

第三种: webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。

#### Vue-router跳转和location.href有什么区别

使用location.href='/url'来跳转，简单方便，但是刷新了页面；  

使用history.pushState('/url')，无刷新页面，静态跳转；  
引进router，然后使用router.push('/url')来跳转，使用了diff算法，实现了按需加载，减少了dom的消耗。  
其实使用router跳转和使用history.pushState()没什么差别的，因为vue-router就是用了history.pushState()，尤其是在history模式下。  

# Vuex

#### `vuex` 是什么？怎么使用它？什么场景下我们会使用到 `vuex`

***vuex` 是什么

*vuex* 是一个专为 *Vue* 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态。每一个 *vuex* 应用的核心就是 *store*（仓库）。“*store*” 基本上就是一个容器，它包含着应用中大部分的状态 (*state*)。

**为什么需要 `vuex`**

由于组件只维护自身的状态(*data*)，组件创建时或者路由切换时，组件会被初始化，从而导致 *data* 也随之销毁。

**使用方法**

在 *main.js* 引入 *store*，注入。只用来读取的状态集中放在 *store* 中， 改变状态的方式是提交 *mutations*，这是个同步的事物，异步逻辑应该封装在 *action* 中。

**什么场景下会使用到 `vuex`**

如果是 *vue* 的小型应用，那么没有必要使用 *vuex*，这个时候使用 *vuex* 反而会带来负担。组件之间的状态传递使用 *props*、自定义事件来传递即可。

但是如果涉及到 *vue* 的大型应用，那么就需要类似于 *vuex* 这样的集中管理状态的状态机来管理所有组件的状态。例如登录状态、加入购物车、音乐播放等，总之只要是开发 *vue* 的大型应用，都推荐使用 *vuex* 来管理所有组件状态。

#### vuex是什么？怎么使用？哪种功能场景使用它？

vue框架中状态管理。在main.js引入store，注入。  

新建了一个目录store.js，….. export 。  

场景有: 单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车  

#### vuex有哪几种属性？

有五种，分别是 State、 Getter、Mutation 、Action、 Module  

state => 基本数据(数据源存放地)  

getters => 从基本数据派生出来的数据  

mutations => 提交更改数据的方法，同步！  

actions => 像一个装饰器，包裹mutations，使之可以异步。  

modules => 模块化Vuex  

#### Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？

如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。  

如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。  

#### vuex是什么？怎么使用？哪种功能场景使用它？  

vue框架中状态管理。在main.js引入store，注入。  
新建了一个目录store.js，….. export 。  
场景有: 单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车  

#### vuex有哪几种属性？  

有五种，分别是 State、 Getter、Mutation 、Action、 Module  
state => 基本数据(数据源存放地)  
getters => 从基本数据派生出来的数据  
mutations => 提交更改数据的方法，同步！  
actions => 像一个装饰器，包裹mutations，使之可以异步。  
modules => 模块化Vuex  

#### Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？  

如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。  

如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。  

# Vue CLI

#### 构建 vue-cli 工程都用到了哪些技术？他们的作用分别是什么？

1. vue.js: vue-cli 工程的核心，主要特点是双向数据绑定和组件系统。
2. vue-router: vue 官方推荐使用的路由框架。
3. vuex: 专为 Vue.js 应用项目开发的状态管理器，主要用于维护 vue 组件间共用的一些 变量 和 方法。
4. axios（或者 fetch、ajax）: 用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。
5. vux等: 一个专为vue设计的移动端UI组件库。
6. webpack: 模块加载和vue-cli工程打包器。
7. eslint: 代码规范工具

#### vue-cli 工程常用的 npm 命令有哪些？

下载 node_modules 资源包的命令: `npm install`

启动 vue-cli 开发环境的 npm命令: `npm run dev`

vue-cli 生成 生产环境部署资源 的 npm命令: `npm run build`

用于查看 vue-cli 生产环境部署资源文件大小的 npm命令: `npm run build --report`

#### 请说出vue.cli项目中src目录每个文件夹和文件的用法？

assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置; app.vue是一个应用主组件；main.js是入口文件。  

# Vue Loader

#### vue-loader是什么？使用它的用途有哪些？

vue文件的一个加载器，将template/js/style转换成js模块。  

用途: js可以写es6、style样式可以scss或less、template可以加jade等  

# VuePress

# Vite

# Vue Devtools

# Vue SSR
